
# --- File: main.py ---

# -*- coding: utf-8 -*-
import os
import asyncio
import structlog
from aiogram import Bot, Dispatcher
from middlewares.context_middleware import ContextMiddleware
from prometheus_client import CollectorRegistry, generate_latest, CONTENT_TYPE_LATEST

from core.logging_setup import setup_logging
from config import BOT_TOKEN, NOTIFY_CHECK_INTERVAL_MIN, DATABASE_URL
from database import init_db
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.ext.asyncio.session import async_sessionmaker
from aiohttp import web
from urllib.parse import urlparse

# routers
from handlers.start import router as start_router
from handlers.help import router as help_router
from handlers.company import router as company_router
from handlers.invite import router as invite_router
from handlers.projects import router as projects_router
from handlers.tasks import router as tasks_router
from handlers.reassign import router as reassign_router
from handlers.status import router as status_router
from handlers.reports import router as reports_router
from handlers.user import router as user_router
from handlers.file_upload import router as file_upload_router
from handlers.files import router as files_router
from handlers.important_stuff import router as important_router
from handlers import admin_billing
from handlers import admin
from handlers import payments
from handlers import example_handler

# middlewares
from middlewares.db_middleware import DbSessionMiddleware
from middlewares.role_checker import RoleCheckerMiddleware
from middlewares.company_middleware import CompanyMiddleware
from middlewares.subscription_checker import SubscriptionCheckerMiddleware
from middlewares.audit_middleware import AuditMiddleware
from middlewares.metrics_middleware import MetricsMiddleware, init_metrics

# jobs
from services.notify_jobs import (
    notify_expiring_trials,
    notify_expiring_subscriptions,
    enforce_expirations,
)
from services.seed import seed_plans

# --- Hawk integration ---
from core.monitoring.hawk_setup import setup_hawk, capture_exception, capture_message


# --- Structlog logging setup ---
setup_logging()
logger = structlog.get_logger(__name__)

# —Å–æ–∑–¥–∞—ë–º –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ä–µ–µ—Å—Ç—Ä, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
registry = CollectorRegistry()

# –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–µ—Ç—Ä–∏–∫–∏
init_metrics(registry)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Hawk –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
setup_hawk()


# --- –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ—Ö–≤–∞—Ç—á–∏–∫ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –æ—à–∏–±–æ–∫ ---
def handle_uncaught_exception(loop, context):
    msg = context.get("exception") or context.get("message")
    logger.error(f"üî• Uncaught exception: {msg}")

    try:
        if context.get("exception"):
            capture_exception(context.get("exception"))
        else:
            capture_message(str(msg))
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Failed to report error to Hawk: {e}")


# --- Health-check server ---
async def start_health_server():
    async def handle_health(request):
        return web.Response(text="OK", status=200)

    async def handle_metrics(request):
        try:
            data = generate_latest(registry)
            return web.Response(body=data, content_type=CONTENT_TYPE_LATEST)
        except Exception as e:
            logger.exception("metrics endpoint error", error=str(e))
            return web.Response(status=500, text=f"metrics error: {e}")

    app = web.Application()
    app.router.add_get("/healthz", handle_health)
    app.router.add_get("/metrics", handle_metrics)

    runner = web.AppRunner(app)
    await runner.setup()
    port = int(os.getenv("PORT", 8080))
    site = web.TCPSite(runner, "0.0.0.0", port)
    await site.start()

    logger.info(f"ü©∫ Health-check + Metrics –∑–∞–ø—É—â–µ–Ω—ã –Ω–∞ –ø–æ—Ä—Ç—É {port}")
    logger.info("üü¢ Bot ready: healthz OK, metrics OK, polling starting‚Ä¶")


async def main():
    # --- Log env info (safe) ---
    db_host = urlparse(DATABASE_URL).hostname
    logger.info("[BOOT] –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞")
    logger.info("[BOOT] DB host", db_host=db_host)
    logger.info("[BOOT] BOT_TOKEN (prefix only)", prefix=BOT_TOKEN[:6])

    logger.info("[INFO] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö...")
    session_pool: async_sessionmaker[AsyncSession] = await init_db()
    logger.info("[INFO] –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –≥–æ—Ç–æ–≤–∞")

    # –±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å–∏–¥ —Ç–∞—Ä–∏—Ñ–æ–≤ (–æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ)
    async with session_pool() as s:
        await seed_plans(s)
        await s.commit()

    # --- Health-check ---
    asyncio.create_task(start_health_server())

    # --- Telegram Bot ---
    bot = Bot(token=BOT_TOKEN)
    dp = Dispatcher()

    # –ø–æ—Ä—è–¥–æ–∫ middleware –∫—Ä–∏—Ç–∏—á–µ–Ω
    dp.message.middleware(DbSessionMiddleware(session_pool))
    dp.callback_query.middleware(DbSessionMiddleware(session_pool))

    dp.message.middleware(RoleCheckerMiddleware())
    dp.callback_query.middleware(RoleCheckerMiddleware())

    dp.message.middleware(CompanyMiddleware())
    dp.callback_query.middleware(CompanyMiddleware())

    dp.message.middleware(SubscriptionCheckerMiddleware())
    dp.callback_query.middleware(SubscriptionCheckerMiddleware())

    dp.message.middleware(AuditMiddleware())
    dp.callback_query.middleware(AuditMiddleware())

    dp.update.middleware(ContextMiddleware())

    dp.message.middleware(MetricsMiddleware())
    dp.callback_query.middleware(MetricsMiddleware())

    # routers
    dp.include_router(start_router)
    dp.include_router(help_router)
    dp.include_router(company_router)
    dp.include_router(invite_router)
    dp.include_router(projects_router)
    dp.include_router(tasks_router)
    dp.include_router(reassign_router)
    dp.include_router(status_router)
    dp.include_router(reports_router)
    dp.include_router(user_router)
    dp.include_router(file_upload_router)
    dp.include_router(files_router)
    dp.include_router(important_router)
    dp.include_router(admin_billing.router)
    dp.include_router(payments.router)
    dp.include_router(admin.router)

    # –ü—Ä–∏–º–µ—Ä –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (—Ç–µ—Å—Ç–æ–≤—ã–π —Ö—ç–Ω–¥–ª–µ—Ä)
    dp.include_router(example_handler.router)

    # —Ñ–æ–Ω–æ–≤—ã–π –≤–æ—Ä–∫–µ—Ä
    asyncio.create_task(billing_notifier(bot, session_pool))

    capture_message("üß™ Hawk test event: bot startup check")

    logger.info("[INFO] –ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    try:
        await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())
    finally:
        await bot.session.close()
        logger.info("[INFO] –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")


async def billing_notifier(bot: Bot, session_pool: async_sessionmaker[AsyncSession]):
    while True:
        async with session_pool() as session:
            try:
                await notify_expiring_trials(session, bot)
                await notify_expiring_subscriptions(session, bot)
                await enforce_expirations(session, bot)
                await session.commit()
            except Exception as e:
                logger.exception("billing_notifier error: %s", e)
                await session.rollback()
        await asyncio.sleep(NOTIFY_CHECK_INTERVAL_MIN * 60)


if __name__ == "__main__":

    def custom_loop():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.set_exception_handler(handle_uncaught_exception)
        return loop

    loop = custom_loop()

try:
    loop.run_until_complete(main())
except KeyboardInterrupt:
    logger.info("üõë Bot stopped by user (KeyboardInterrupt)")
finally:
    loop.close()


# --- File: middlewares/role_checker.py ---

import logging
from typing import Callable, Awaitable, Any, Dict
from aiogram import BaseMiddleware
from aiogram.types import Message, CallbackQuery
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from models.user import User
from utils.enums import UserRole

logger = logging.getLogger(__name__)


class RoleCheckerMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[Message | CallbackQuery, Dict[str, Any]], Awaitable[Any]],
        event: Message | CallbackQuery,
        data: Dict[str, Any],
    ) -> Any:
        session: AsyncSession = data.get("session")
        if not session:
            raise RuntimeError(
                "DbSessionMiddleware must run before RoleCheckerMiddleware."
            )

        tg_id = None
        if isinstance(event, Message):
            tg_id = event.from_user.id
        elif isinstance(event, CallbackQuery):
            tg_id = event.from_user.id

        if tg_id is None:
            return await handler(event, data)

        # –∏—â–µ–º –ø–æ tg_id, –∞ –Ω–µ –ø–æ id
        result = await session.execute(select(User).where(User.tg_id == tg_id))
        user = result.scalar_one_or_none()

        if not user:
            user = User(
                tg_id=tg_id,
                role=UserRole.worker,  # –∏–ª–∏ UserRole.WORKER.value, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                company_id=None,
            )
            session.add(user)
            await session.flush()
            logger.info("–ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å %s —Å–æ–∑–¥–∞–Ω.", tg_id)

        data["user"] = user
        return await handler(event, data)


# --- File: middlewares/db_middleware.py ---

# middlewares/db_middleware.py
from aiogram import BaseMiddleware
from typing import Callable, Dict, Any
import time
import structlog
from prometheus_client import Counter, Histogram

logger = structlog.get_logger()

DB_REQUESTS_TOTAL = Counter("db_requests_total", "Total DB session usages", ["status"])
DB_REQUEST_DURATION = Histogram(
    "db_request_duration_seconds", "DB session duration in seconds", ["status"]
)


class DbSessionMiddleware(BaseMiddleware):
    """Best-practice: —á–∏—Å—Ç–∞—è —Ä–∞–±–æ—Ç–∞ —Å –ë–î + –º–µ—Ç—Ä–∏–∫–∏, –±–µ–∑ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç Hawk."""

    def __init__(self, session_pool):
        super().__init__()
        self.session_pool = session_pool

    async def __call__(self, handler: Callable, event, data: Dict[str, Any]) -> Any:
        start = time.monotonic()
        status = "ok"
        try:
            async with self.session_pool() as session:
                data["session"] = session
                result = await handler(event, data)
                return result
        except Exception:
            status = "error"
            raise
        finally:
            duration = time.monotonic() - start
            DB_REQUESTS_TOTAL.labels(status=status).inc()
            DB_REQUEST_DURATION.labels(status=status).observe(duration)
            logger.info(
                "DB session finished", duration=f"{duration:.3f}s", status=status
            )


# --- File: middlewares/company_middleware.py ---

# middlewares/company_middleware.py
import logging
from typing import Callable, Dict, Any, Awaitable
from aiogram import BaseMiddleware
from aiogram.types import Message, CallbackQuery
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from models import User

logger = logging.getLogger(__name__)


class CompanyMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[Message | CallbackQuery, Dict[str, Any]], Awaitable[Any]],
        event: Message | CallbackQuery,
        data: Dict[str, Any],
    ) -> Any:
        user: User = data.get("user")
        session: AsyncSession = data.get("session")
        if not user:
            raise RuntimeError(
                "CompanyMiddleware must run after RoleCheckerMiddleware."
            )
        if not session:
            raise RuntimeError("DbSessionMiddleware must run before CompanyMiddleware.")

        data["has_company"] = user.company_id is not None
        logger.info(
            "CompanyMiddleware: tg_id=%s has_company=%s company_id=%s",
            user.tg_id,
            data["has_company"],
            user.company_id,
        )

        cid = user.company_id if user.company_id is not None else -1
        # –∏–º—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–æ: app.company_id
        await session.execute(text(f"SET LOCAL app.company_id = {cid}"))

        return await handler(event, data)


# --- File: middlewares/subscription_checker.py ---

import logging
from typing import Callable, Awaitable, Any, Dict
from aiogram import BaseMiddleware
from aiogram.types import Message, CallbackQuery

logger = logging.getLogger(__name__)

# –∫–æ–º–∞–Ω–¥—ã/—Å–æ–±—ã—Ç–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å –ë–ï–ó –∫–æ–º–ø–∞–Ω–∏–∏
WHITELIST = (
    "/start",
    "/help",
    "/create_company",
    "/join",
    "/buy",  # –º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å, –µ—Å–ª–∏ —Ö–æ—á–µ—à—å –ø—Ä–æ–¥–∞–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —á–ª–µ–Ω–∞–º –∫–æ–º–ø–∞–Ω–∏–∏
)


class SubscriptionCheckerMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[Message | CallbackQuery, Dict[str, Any]], Awaitable[Any]],
        event: Message | CallbackQuery,
        data: Dict[str, Any],
    ) -> Any:
        has_company: bool = data.get("has_company", False)

        # --- –µ—Å–ª–∏ —ç—Ç–æ callback, –≤—Å–µ–≥–¥–∞ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º ---
        if isinstance(event, CallbackQuery):
            return await handler(event, data)

        # --- –µ—Å–ª–∏ —ç—Ç–æ Message ---
        text = (event.text or "").strip()

        # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º whitelisted –∫–æ–º–∞–Ω–¥—ã
        if text and any(text.startswith(x) for x in WHITELIST):
            return await handler(event, data)

        # –±–ª–æ–∫–∏—Ä—É–µ–º, –µ—Å–ª–∏ –Ω–µ—Ç –∫–æ–º–ø–∞–Ω–∏–∏
        if not has_company:
            await event.answer(
                "–ß—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å, —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç–µ—Å—å –∫ –∫–æ–º–ø–∞–Ω–∏–∏. "
                "–†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å: /create_company. –†–∞–±–æ—á–∏–π/–ë—Ä–∏–≥–∞–¥–∏—Ä: /join <ID –∫–æ–º–ø–∞–Ω–∏–∏>."
            )
            return

        return await handler(event, data)


# --- File: middlewares/audit_middleware.py ---

# middlewares/audit_middleware.py

from aiogram import BaseMiddleware
from typing import Callable, Dict, Any


class AuditMiddleware(BaseMiddleware):
    async def __call__(
        self, handler: Callable, event: Any, data: Dict[str, Any]
    ) -> Any:
        session = data.get("session")
        user = data.get("event_from_user")  # aiogram user

        if session and user:
            session.info["actor_id"] = user.id  # —Å–æ—Ö—Ä–∞–Ω—è–µ–º Telegram ID –¥–ª—è —Å–≤—è–∑–∏

        return await handler(event, data)


# --- File: handlers/start.py ---

# app/handlers/start.py
import logging
from aiogram import Router, types, F
from aiogram.filters import Command
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy.ext.asyncio import AsyncSession
from models.user import User
from services.users import set_user_role_and_company
from utils.enums import UserRole

router = Router(name="start")
logger = logging.getLogger(__name__)

# –í—Å–µ —Ä–æ–ª–∏, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã –≤ —Å–∏—Å—Ç–µ–º–µ (–¥–ª—è –∫–Ω–æ–ø–æ–∫)
role_map = {
    "—Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å": UserRole.manager,
    "–±—Ä–∏–≥–∞–¥–∏—Ä": UserRole.foreman,
    "—Ä–∞–±–æ—á–∏–π": UserRole.worker,
    "–∫–ª–∏–µ–Ω—Ç": UserRole.client,
    "–ø–æ—Å—Ç–∞–≤—â–∏–∫": UserRole.supplier,
    "–±—É—Ö–≥–∞–ª—Ç–µ—Ä": UserRole.accountant,
}

# –†–∞–±–æ—á–∏–µ —Ä–æ–ª–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∞–ª—å–Ω–æ –ø–æ–¥–¥–µ—Ä–∂–∞–Ω—ã —Å–µ–π—á–∞—Å
available_roles = {
    UserRole.manager,
    UserRole.foreman,
    UserRole.worker,
}


@router.message(Command("start"))
async def start_cmd(message: types.Message, user: User):
    """–•–µ–Ω–¥–ª–µ—Ä –Ω–∞ –∫–æ–º–∞–Ω–¥—É /start"""
    if user.company_id:
        await message.answer(
            f"–í—ã —É–∂–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ –∫–æ–º–ø–∞–Ω–∏–∏ ID={user.company_id}.\n"
            f"–ö–æ–º–∞–Ω–¥—ã: /buy ‚Äî –æ–ø–ª–∞—Ç–∞, /admin_company_status <id> ‚Äî —Å—Ç–∞—Ç—É—Å (–¥–ª—è –∞–¥–º–∏–Ω–æ–≤)."
        )
        return

    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫ –∏–∑ role_map
    kb = InlineKeyboardBuilder()
    for label in role_map.keys():
        kb.button(text=label.capitalize(), callback_data=f"set_role:{label}")
    kb.adjust(1)

    await message.answer(
        "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à—É —Ä–æ–ª—å:", reply_markup=kb.as_markup()
    )


@router.callback_query(F.data.startswith("set_role:"))
async def callback_set_role(
    callback: types.CallbackQuery, session: AsyncSession, user: User
):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–∏"""

    raw_role = callback.data.split(":", 1)[1]
    role = role_map.get(raw_role)

    if not role:
        await callback.answer("–ù–µ–≤–µ—Ä–Ω–∞—è —Ä–æ–ª—å", show_alert=True)
        return

    # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –µ—â—ë –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö —Ä–æ–ª–µ–π
    if role not in available_roles:
        await callback.answer("‚ö†Ô∏è –≠—Ç–∞ —Ä–æ–ª—å –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞", show_alert=True)
        return

    try:
        await set_user_role_and_company(session, user.id, role)

        if role == UserRole.manager:
            txt = (
                "‚úÖ –û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤—ã —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å.\n"
                "–°–æ–∑–¥–∞–π—Ç–µ –≤–∞—à—É –∫–æ–º–ø–∞–Ω–∏—é:\n"
                "`/create_company <–ù–∞–∑–≤–∞–Ω–∏–µ–ö–æ–º–ø–∞–Ω–∏–∏>`"
            )
        else:
            txt = (
                f"‚úÖ –û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤—ã {raw_role}.\n"
                "–ß—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∫–æ–º–ø–∞–Ω–∏–∏, –∑–∞–ø—Ä–æ—Å–∏—Ç–µ ID —É —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è –∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n"
                "`/join <ID –∫–æ–º–ø–∞–Ω–∏–∏>`"
            )

        await callback.message.edit_text(txt, parse_mode="Markdown")
        await callback.answer()

    except Exception:
        logger.exception("–û—à–∏–±–∫–∞ –≤ callback_set_role")
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞", show_alert=True)


# --- File: handlers/company.py ---

import logging
from aiogram import Router, types, F
from sqlalchemy.ext.asyncio import AsyncSession
from services.companies import create_company as svc_create_company
from models import Company
from utils.enums import UserRole
from services.audit import log_action

router = Router(name="company")
logger = logging.getLogger(__name__)


@router.message(F.text.regexp(r"^/create_company\s+.+"))
async def create_company_cmd(message: types.Message, session: AsyncSession, user):
    if user.company_id:
        await message.answer("‚õî –í—ã —É–∂–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ –∫–æ–º–ø–∞–Ω–∏–∏.")
        return

    company_name = message.text.split(maxsplit=1)[1].strip()
    try:
        company = await svc_create_company(session, company_name, user.id)
        user.company_id = company.id
        user.role = UserRole.manager  # —Å–æ–∑–¥–∞—Ç–µ–ª—å –∫–æ–º–ø–∞–Ω–∏–∏ = —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å
        session.add(user)
        await session.commit()

        # –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        await log_action(
            session,
            actor_user_id=user.id,
            actor_tg_id=user.tg_id,
            action="create_company",
            entity_type="Company",
            entity_id=company.id,
            payload={"name": company.name},
        )

        logger.info(
            "–ö–æ–º–ø–∞–Ω–∏—è %s (%s) —Å–æ–∑–¥–∞–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º %s",
            company.id,
            company.name,
            user.tg_id,
        )

        await message.answer(
            f"–ö–æ–º–ø–∞–Ω–∏—è '{company.name}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!\n"
            f"–í–∞—à ID –∫–æ–º–ø–∞–Ω–∏–∏: {company.id}."
        )
    except Exception as e:
        await session.rollback()
        logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–æ–º–ø–∞–Ω–∏–∏: %s", e)
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–æ–º–ø–∞–Ω–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")


@router.message(F.text.regexp(r"^/join\s+\d+(\s+(—Ä–∞–±–æ—á–∏–π|–±—Ä–∏–≥–∞–¥–∏—Ä))?$"))
async def join_company_cmd(message: types.Message, session: AsyncSession, user):
    if user.company_id:
        await message.answer("–í—ã —É–∂–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ –∫–æ–º–ø–∞–Ω–∏–∏.")
        return

    parts = message.text.split()
    company_id = int(parts[1])
    role_str = parts[2] if len(parts) > 2 else "—Ä–∞–±–æ—á–∏–π"

    company = await session.get(Company, company_id)
    if not company:
        await message.answer("–ö–æ–º–ø–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return

    try:
        role_map = {
            "—Ä–∞–±–æ—á–∏–π": UserRole.worker,
            "–±—Ä–∏–≥–∞–¥–∏—Ä": UserRole.foreman,
        }

        role_enum = role_map.get(role_str.lower())
        if not role_enum:
            await message.answer("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω–∞—è —Ä–æ–ª—å. –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–æ–ª–∏: —Ä–∞–±–æ—á–∏–π, –±—Ä–∏–≥–∞–¥–∏—Ä.")
            return

        user.company_id = company.id
        user.role = role_enum
        session.add(user)
        await session.commit()

        # –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        await log_action(
            session,
            actor_user_id=user.id,
            actor_tg_id=user.tg_id,
            action="join_company",
            entity_type="Company",
            entity_id=company.id,
            payload={"role": role_enum.name, "user_tg_id": user.tg_id},
        )

        logger.info(
            "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å %s –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –∫–æ–º–ø–∞–Ω–∏–∏ %s –∫–∞–∫ %s",
            user.tg_id,
            company.id,
            role_enum.name,
        )

        if len(parts) > 2:
            await message.answer(
                f"‚úÖ –í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –∫–æ–º–ø–∞–Ω–∏–∏ '{company.name}' (ID={company.id}) –∫–∞–∫ {role_enum.name.capitalize()}."
            )
        else:
            await message.answer(
                f"‚úÖ –í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –∫–æ–º–ø–∞–Ω–∏–∏ '{company.name}' (ID={company.id}) –∫–∞–∫ —Ä–∞–±–æ—á–∏–π.\n\n"
                f"–ï—Å–ª–∏ –≤—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –±—Ä–∏–≥–∞–¥–∏—Ä–æ–º ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n"
                f"`/join {company.id} –±—Ä–∏–≥–∞–¥–∏—Ä`",
                parse_mode="Markdown",
            )
    except Exception as e:
        await session.rollback()
        logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏: %s", e)
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")


# --- File: handlers/tasks.py ---

from aiogram import Router, types
from aiogram.filters import Command
from sqlalchemy.ext.asyncio import AsyncSession
from models.user import User
from models.project import Project
from services.tasks import create_task, get_my_tasks
from services.projects import get_project_by_id_and_company
from utils.helpers import format_tasks_list
from utils.decorators import is_manager_or_foreman
from services.audit import log_action
import logging  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º logging

# –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(
    level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s"
)

router = Router()


@router.message(Command("add_task"))
@is_manager_or_foreman
async def add_task_cmd(message: types.Message, session: AsyncSession, user: User):
    logging.debug(f"–ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.id}")

    args = message.text.split(maxsplit=2)
    if len(args) < 3:
        await message.answer(
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ ID –ø—Ä–æ–µ–∫—Ç–∞, –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏."
        )
        return

    try:
        project_id = int(args[1])
        title = args[2].strip()
        description = " ".join(args[3:]) if len(args) > 3 else ""
    except (ValueError, IndexError):
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã. ID –ø—Ä–æ–µ–∫—Ç–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
        return

    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞
        project = await get_project_by_id_and_company(
            session, project_id, user.company_id
        )
        if not project:
            await message.answer("–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤–∞—à–µ–π –∫–æ–º–ø–∞–Ω–∏–∏.")
            return

        # –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É
        task = await create_task(
            session, title, description, project_id, user.company_id, user.id
        )

        # –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏
        await log_action(
            session,
            actor_user_id=user.id,
            actor_tg_id=user.tg_id,
            action="create_task",
            entity_type="Task",
            entity_id=task.id,
            payload={
                "title": task.title,
                "description": task.description,
                "project_id": project_id,
            },
        )

        logging.info(f"–ó–∞–¥–∞—á–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞: ID={task.id}")
        await message.answer(
            f"–ó–∞–¥–∞—á–∞ '{task.title}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –≤ –ø—Ä–æ–µ–∫—Ç–µ '{project.name}'!"
        )
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {str(e)}")
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏.")


@router.message(Command("my_tasks"))
async def my_tasks_cmd(message: types.Message, session: AsyncSession, user: User):
    if not user.company_id:
        await message.answer("–í—ã –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ –∫–æ–º–ø–∞–Ω–∏–∏.")
        return

    tasks = await get_my_tasks(session, user.id)
    if not tasks:
        await message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–¥–∞—á.")
        return

    for task in tasks:
        task.project = await session.get(Project, task.project_id)

    text = format_tasks_list(tasks)
    await message.answer(text)


# --- File: handlers/user.py ---

# handlers/user.py

from aiogram import Router
from aiogram.types import Message
from aiogram.filters import Command
from sqlalchemy.ext.asyncio import AsyncSession
from services.users import get_user_by_tg_id

router = Router()


@router.message(Command("me"))
async def me_cmd(message: Message, session: AsyncSession):
    user = await get_user_by_tg_id(session, message.from_user.id)
    if not user:
        await message.answer("–í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start")
    else:
        await message.answer(
            f"–í–∞—à ID: {user.id}\n"
            f"–†–æ–ª—å: {user.role}\n"
            f"–ö–æ–º–ø–∞–Ω–∏—è ID: {user.company_id}"
        )


# --- File: handlers/file_upload.py ---

import uuid
import os
import logging
import aiohttp
from aiogram import Router, F, Bot
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from models.project import Project
from models.task import Task
from models.user import User
from services.files import create_file
from storage.s3 import generate_presigned_put_url

router = Router()
logger = logging.getLogger(__name__)


class FileUploadState(StatesGroup):
    """–°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –ø–æ—à–∞–≥–æ–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞."""

    waiting_for_project = State()
    waiting_for_task = State()
    waiting_for_file = State()


# -- –ö–æ–º–∞–Ω–¥—ã –∏ —Ö—ç–Ω–¥–ª–µ—Ä—ã --


@router.message(Command("upload", "add_file"))
async def cmd_upload_start(
    message: Message, state: FSMContext, session: AsyncSession, user: User
):
    """–ù–∞—á–∏–Ω–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞."""
    # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ–µ–∫—Ç—ã –¥–ª—è —Ç–µ–∫—É—â–µ–π –∫–æ–º–ø–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    projects_stmt = select(Project).where(Project.company_id == user.company_id)
    projects = (await session.execute(projects_stmt)).scalars().all()

    if not projects:
        await message.answer("–í –≤–∞—à–µ–π –∫–æ–º–ø–∞–Ω–∏–∏ –Ω–µ—Ç –ø—Ä–æ–µ–∫—Ç–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤.")
        await state.clear()
        return

    buttons = [
        [InlineKeyboardButton(text=p.name, callback_data=f"upload_project:{p.id}")]
        for p in projects
    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–µ–∫—Ç, –∫ –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–∞–π–ª:", reply_markup=keyboard
    )
    await state.set_state(FileUploadState.waiting_for_project)


@router.callback_query(
    F.data.startswith("upload_project:"), FileUploadState.waiting_for_project
)
async def upload_select_project(
    callback_query: CallbackQuery, state: FSMContext, session: AsyncSession, user: User
):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä –ø—Ä–æ–µ–∫—Ç–∞."""
    project_id = int(callback_query.data.split(":")[1])
    await state.update_data(project_id=project_id)

    tasks_stmt = select(Task).where(Task.project_id == project_id)
    tasks = (await session.execute(tasks_stmt)).scalars().all()

    if not tasks:
        await callback_query.message.edit_text(
            "–í —ç—Ç–æ–º –ø—Ä–æ–µ–∫—Ç–µ –Ω–µ—Ç –∑–∞–¥–∞—á –¥–ª—è –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤."
        )
        await state.clear()
        return

    buttons = [
        [
            InlineKeyboardButton(
                text=f"{t.title} (ID: {t.id})", callback_data=f"upload_task:{t.id}"
            )
        ]
        for t in tasks
    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    await callback_query.message.edit_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É, –∫ –∫–æ—Ç–æ—Ä–æ–π –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–∞–π–ª:", reply_markup=keyboard
    )
    await state.set_state(FileUploadState.waiting_for_task)


@router.callback_query(
    F.data.startswith("upload_task:"), FileUploadState.waiting_for_task
)
async def upload_select_task(callback_query: CallbackQuery, state: FSMContext):
    """–ó–∞–≤–µ—Ä—à–∞–µ—Ç –≤—ã–±–æ—Ä –∑–∞–¥–∞—á–∏ –∏ –ø—Ä–æ—Å–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª."""
    task_id = int(callback_query.data.split(":")[1])
    await state.update_data(task_id=task_id)
    await callback_query.message.edit_text(
        "–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Ñ–∞–π–ª (–¥–æ–∫—É–º–µ–Ω—Ç –∏–ª–∏ —Ñ–æ—Ç–æ)."
    )
    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ —Ç–æ –∂–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, —á—Ç–æ –∏ —Ä–∞–Ω—å—à–µ, –Ω–æ —Ç–µ–ø–µ—Ä—å –∂–¥–µ–º –∏–º–µ–Ω–Ω–æ —Ñ–∞–π–ª
    await state.set_state(FileUploadState.waiting_for_file)


@router.message(FileUploadState.waiting_for_file, F.photo | F.document)
async def handle_file(
    message: Message, state: FSMContext, session: AsyncSession, user: User, bot: Bot
):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –µ–≥–æ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ."""
    try:
        data = await state.get_data()
        task_id = data.get("task_id")

        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ
        file_info = message.document if message.document else message.photo[-1]

        # –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –ª–æ–≥–∏–∫—É –ø–æ–ª—É—á–µ–Ω–∏—è –∏–º–µ–Ω–∏ –∏ MIME-—Ç–∏–ø–∞
        if message.document:
            original_name = file_info.file_name
            mime_type = file_info.mime_type
        else:  # F.photo
            original_name = f"photo_{file_info.file_unique_id}.jpg"
            mime_type = "image/jpeg"  # –£ —Ñ–æ—Ç–æ –Ω–µ—Ç mime_type, –ø–æ—ç—Ç–æ–º—É –∑–∞–¥–∞–µ–º —è–≤–Ω–æ

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–ª—é—á –¥–ª—è S3. –ò—Å–ø–æ–ª—å–∑—É–µ–º company_id –¥–ª—è –∏–∑–æ–ª—è—Ü–∏–∏.
        file_extension = os.path.splitext(original_name)[1]
        s3_key = (
            f"company_{user.company_id}/task_{task_id}/{uuid.uuid4()}{file_extension}"
        )

        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª —Å —Å–µ—Ä–≤–µ—Ä–æ–≤ Telegram
        telegram_file = await bot.get_file(file_info.file_id)
        file_bytes = await bot.download_file(telegram_file.file_path)

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º URL –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞
        presigned_url = await generate_presigned_put_url(s3_key)

        if not presigned_url:
            await message.answer(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–µ –∫ –∑–∞–≥—Ä—É–∑–∫–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
            )
            await state.clear()
            return

        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª –≤ S3
        async with aiohttp.ClientSession() as http_session:
            await http_session.put(presigned_url, data=file_bytes)

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ –≤ –ë–î
        new_file = await create_file(
            session=session,
            task_id=task_id,
            company_id=user.company_id,  # <--- –ò–°–ü–†–ê–í–õ–ï–ù–û: –¢–µ–ø–µ—Ä—å –ø–µ—Ä–µ–¥–∞–µ–º company_id
            uploader_id=user.id,
            original_name=original_name,
            mime_type=mime_type,
            size=file_info.file_size,
            s3_key=s3_key,
        )
        await message.answer(
            f"–§–∞–π–ª '{new_file.original_name}' —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–ª—ë–Ω –∫ –∑–∞–¥–∞—á–µ! ‚úÖ"
        )

    except Exception as e:
        logger.error(f"Error saving file info to DB: {e}")
        await message.answer(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –æ —Ñ–∞–π–ª–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
        )
    finally:
        await state.clear()


# --- File: handlers/projects.py ---

from aiogram import Router, types
from aiogram.filters import Command
from sqlalchemy.ext.asyncio import AsyncSession
from models.user import User
from services.projects import create_project, get_projects_by_company_id
from utils.decorators import is_manager, is_manager_or_foreman
from services.audit import log_action
import logging

# –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(
    level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s"
)

router = Router()


@router.message(Command("add_project"))
@is_manager
async def add_project_cmd(message: types.Message, session: AsyncSession, user: User):
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer(
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞.\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `/add_project <–ù–∞–∑–≤–∞–Ω–∏–µ–ü—Ä–æ–µ–∫—Ç–∞>`"
        )
        return

    project_name = args[1].strip()

    try:
        project = await create_project(session, project_name, user.company_id)
        logging.debug(
            f"–°–æ–∑–¥–∞–Ω –ø—Ä–æ–µ–∫—Ç: ID={project.id}, Name={project.name}, CompanyID={project.company_id}"
        )

        # –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        await log_action(
            session,
            actor_user_id=user.id,
            actor_tg_id=user.tg_id,
            action="create_project",
            entity_type="Project",
            entity_id=project.id,
            payload={"name": project.name, "company_id": project.company_id},
        )

        await message.answer(
            f"–ü—Ä–æ–µ–∫—Ç '{project.name}' —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω! ID: {project.id}"
        )
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞: {str(e)}")
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞")


@router.message(Command("show_projects"))
@is_manager_or_foreman
async def show_projects_cmd(message: types.Message, session: AsyncSession, user: User):
    logging.debug(f"–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–æ–≤ –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏: {user.company_id}")

    try:
        projects = await get_projects_by_company_id(session, user.company_id)
        logging.debug(f"–ù–∞–π–¥–µ–Ω–æ –ø—Ä–æ–µ–∫—Ç–æ–≤: {len(projects)}")

        if not projects:
            await message.answer("–ü—Ä–æ–µ–∫—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
            return

        projects_list = "\n".join(
            [f"{p.id}. {p.name} (CompanyID: {p.company_id})" for p in projects]
        )
        await message.answer(f"–°–ø–∏—Å–æ–∫ –≤–∞—à–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤:\n{projects_list}")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ–µ–∫—Ç–æ–≤: {str(e)}")
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –ø—Ä–æ–µ–∫—Ç–æ–≤")


@router.message(Command("list_projects_all"))
@is_manager
async def list_all_projects(message: types.Message, session: AsyncSession, user: User):
    try:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø—Ä–æ–µ–∫—Ç—ã –±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ø–æ –∫–æ–º–ø–∞–Ω–∏–∏
        result = await session.execute("SELECT id, name, company_id FROM projects")
        projects = result.fetchall()

        if not projects:
            await message.answer("–í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –ø—Ä–æ–µ–∫—Ç–æ–≤")
            return

        projects_list = "\n".join(
            [f"{p[0]}. {p[1]} (CompanyID: {p[2]})" for p in projects]
        )
        await message.answer(f"–í—Å–µ –ø—Ä–æ–µ–∫—Ç—ã –≤ –±–∞–∑–µ:\n{projects_list}")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤—Å–µ—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤: {str(e)}")
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤—Å–µ—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤")


# --- File: handlers/reports.py ---

# handlers/reports.py
from aiogram import Router
from aiogram.types import Message
from aiogram.filters import Command
from sqlalchemy.ext.asyncio import AsyncSession
from models.user import User
from services.reports import get_user_report

router = Router()


@router.message(Command("reports"))
async def reports_cmd(message: Message, session: AsyncSession, user: User):
    report_data = await get_user_report(session, user)
    await message.answer(
        f"**–í–∞—à –æ—Ç—á—ë—Ç:**\n"
        f"–ó–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö –∑–∞–¥–∞—á: {report_data['completed_tasks']}\n"
        f"–ó–∞–¥–∞—á –≤ —Ä–∞–±–æ—Ç–µ: {report_data['in_progress_tasks']}"
    )


# --- File: handlers/invite.py ---

# handlers/invite.py

from aiogram import Router, types
from aiogram.filters import Command
from models.user import User
from utils.decorators import is_manager

router = Router()


@router.message(Command("invite"))
@is_manager
async def create_invite_cmd(message: types.Message, user: User):
    if not user.company_id:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –∏–ª–∏ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç–µ—Å—å –∫ –∫–æ–º–ø–∞–Ω–∏–∏.")
        return

    # –í—Ä–µ–º–µ–Ω–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º company_id –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∫–æ–¥–∞-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è.
    invite_code = user.company_id
    await message.answer(
        f"–í–∞—à –∫–æ–¥-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥–ª—è —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤: `{invite_code}`\n"
        f"–ü–æ–ø—Ä–æ—Å–∏—Ç–µ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—É: `/join {invite_code}`"
    )


# --- File: handlers/reassign.py ---

from aiogram import Router, types
from aiogram.filters import Command
from sqlalchemy.ext.asyncio import AsyncSession
from models.user import User
from services.tasks import reassign_task
from utils.decorators import is_manager_or_foreman

router = Router()


@router.message(Command("reassign_task"))
@is_manager_or_foreman
async def reassign_task_cmd(message: types.Message, session: AsyncSession, user: User):
    args = message.text.split()
    if len(args) < 3:
        await message.answer(
            "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `/reassign_task <ID –∑–∞–¥–∞—á–∏> <ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è>`"
        )
        return

    try:
        task_id = int(args[1])
        new_assignee_id = int(args[2])
    except ValueError:
        await message.answer("ID –∑–∞–¥–∞—á–∏ –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —á–∏—Å–ª–∞–º–∏.")
        return

    task = await reassign_task(
        session, task_id, new_assignee_id, user.company_id
    )  # <- –î–æ–±–∞–≤–∏–ª–∏ company_id
    if task:

        await message.answer(
            f"–ó–∞–¥–∞—á–∞ '{task.title}' —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å ID {new_assignee_id}."
        )
    else:
        await message.answer("–ó–∞–¥–∞—á–∞ —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")


# --- File: handlers/status.py ---

from aiogram import Router, types
from aiogram.filters import Command
from sqlalchemy.ext.asyncio import AsyncSession
from models.user import User
from services.tasks import set_task_status

router = Router()


# --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: set_status_cmd ---
# –î–æ–±–∞–≤–ª—è–µ–º user.company_id –≤ –≤—ã–∑–æ–≤ —Å–µ—Ä–≤–∏—Å–∞
@router.message(Command("set_status"))
async def set_status_cmd(message: types.Message, session: AsyncSession, user: User):
    args = message.text.split(maxsplit=2)
    if len(args) < 3:
        await message.answer(
            "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `/set_status <ID –∑–∞–¥–∞—á–∏> <–°—Ç–∞—Ç—É—Å>`"
        )
        return

    try:
        task_id = int(args[1])
        status = args[2]
    except ValueError:
        await message.answer("ID –∑–∞–¥–∞—á–∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
        return

    task = await set_task_status(
        session, task_id, status, user.company_id
    )  # <- –î–æ–±–∞–≤–∏–ª–∏ company_id
    if task:
        await message.answer(
            f"–°—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ '{task.title}' —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω—ë–Ω –Ω–∞ '{task.status}'."
        )
    else:
        await message.answer("–ó–∞–¥–∞—á–∞ —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")


# --- File: handlers/help.py ---

# handlers/help.py
from aiogram import Router
from aiogram.types import Message
from aiogram.filters import Command
from models.user import User
from sqlalchemy.ext.asyncio import AsyncSession
from utils.enums import UserRole

router = Router()


@router.message(Command("help"))
async def cmd_help(message: Message, session: AsyncSession, user: User):
    commands = ["/start ‚Äì —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∏–ª–∏ –Ω–∞—á–∞–ª–æ —Ä–∞–±–æ—Ç—ã", "/help ‚Äì –ø–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É"]

    if not user.company_id:
        commands.append("/create_company <–Ω–∞–∑–≤–∞–Ω–∏–µ> ‚Äì —Å–æ–∑–¥–∞—Ç—å –∫–æ–º–ø–∞–Ω–∏—é")
        commands.append(
            "/join <ID> [—Ä–æ–ª—å] ‚Äì –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∫–æ–º–ø–∞–Ω–∏–∏ (—Ä–æ–ª—å: —Ä–∞–±–æ—á–∏–π/–±—Ä–∏–≥–∞–¥–∏—Ä)"
        )

    if user.role == UserRole.manager:
        commands += [
            "/invite ‚Äì –ø–æ–ª—É—á–∏—Ç—å –∫–æ–¥-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ",
            "/add_project ‚Äì –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–µ–∫—Ç",
            "/add_task ‚Äì –¥–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É",
            "/show_projects ‚Äì –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–æ–µ–∫—Ç—ã",
            "/reassign_task ‚Äì –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–∏—Ç—å –∑–∞–¥–∞—á—É",
            "/reports ‚Äì –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –æ—Ç—á—ë—Ç—ã",
        ]

    if user.role == UserRole.foreman:
        commands += [
            "/add_project ‚Äì –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–µ–∫—Ç",
            "/add_task ‚Äì –¥–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É",
            "/show_projects ‚Äì –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–æ–µ–∫—Ç—ã",
            "/my_tasks ‚Äì –ø–æ–∫–∞–∑–∞—Ç—å –º–æ–∏ –∑–∞–¥–∞—á–∏",
            "/reassign_task ‚Äì –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–∏—Ç—å –∑–∞–¥–∞—á—É",
            "/set_status ‚Äì –∏–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏",
        ]

    if user.role == UserRole.worker:
        commands += [
            "/my_tasks ‚Äì –ø–æ–∫–∞–∑–∞—Ç—å –º–æ–∏ –∑–∞–¥–∞—á–∏",
            "/set_status ‚Äì –∏–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏",
        ]

    if user.role == UserRole.admin:
        commands += [
            "/list_companies ‚Äì —Å–ø–∏—Å–æ–∫ –∫–æ–º–ø–∞–Ω–∏–π",
            "/force_plan <company_id> <plan_code> ‚Äì –Ω–∞–∑–Ω–∞—á–∏—Ç—å —Ç–∞—Ä–∏—Ñ",
            "/force_extend_trial <company_id> <days> ‚Äì –ø—Ä–æ–¥–ª–∏—Ç—å —Ç—Ä–∏–∞–ª",
        ]

    await message.answer("–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n" + "\n".join(commands))


# --- File: handlers/files.py ---

from aiogram import Router
from aiogram.types import Message
from aiogram.filters import Command
from sqlalchemy.ext.asyncio import AsyncSession
from services.files import get_file_by_id
from storage.s3 import generate_presigned_get_url
from models.user import User
import uuid
import logging

router = Router()
logger = logging.getLogger(__name__)


@router.message(Command("get_file"))
async def get_file_cmd(message: Message, session: AsyncSession, user: User):
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer(
            "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /get_file <ID —Ñ–∞–π–ª–∞>"
        )
        return

    try:
        file_id = uuid.UUID(args[1])
    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID —Ñ–∞–π–ª–∞. ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å UUID.")
        return

    file = await get_file_by_id(session, file_id)

    if not file:
        await message.answer("–§–∞–π–ª —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return

    if file.company_id != user.company_id:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ñ–∞–π–ª—É.")
        return

    presigned_url = await generate_presigned_get_url(file.s3_key)

    if presigned_url:
        await message.answer(
            f"–§–∞–π–ª '{file.original_name}' –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Å—Å—ã–ª–∫–µ:\n{presigned_url}\n\n–°—Å—ã–ª–∫–∞ –±—É–¥–µ—Ç –∞–∫—Ç–∏–≤–Ω–∞ 1 —á–∞—Å."
        )
    else:
        await message.answer(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Å—ã–ª–∫–∏ –Ω–∞ —Ñ–∞–π–ª. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
        )


# --- File: handlers/admin_billing.py ---

# handlers/admin_billing.py
from aiogram import Router, types, F
from sqlalchemy.ext.asyncio import AsyncSession
from utils.enums import UserRole
from services.subscriptions import (
    extend_trial,
    set_plan_for_company,
    pause_subscription,
    resume_subscription,
    cancel_subscription,
    get_company_subscription_status,
)

router = Router(name="admin_billing")


def _is_admin(user) -> bool:
    return getattr(user, "role", None) == UserRole.admin.value


def fmt_date(dt):
    return dt.strftime("%Y-%m-%d") if dt else "‚Äî"


@router.message(F.text.regexp(r"^/admin_extend_trial\s+\d+\s+\d+$"))
async def cmd_extend_trial(message: types.Message, session: AsyncSession, user):
    if not _is_admin(user):
        await message.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    _, company_id, extra_days = message.text.split()
    company_id = int(company_id)
    extra_days = int(extra_days)

    trial = await extend_trial(session, company_id, extra_days)
    await message.answer(
        f"‚úÖ –¢—Ä–∏–∞–ª –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {company_id} –ø—Ä–æ–¥–ª—ë–Ω. "
        f"–ù–æ–≤–∞—è –¥–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è: {trial.expires_at:%Y-%m-%d}."
    )


@router.message(F.text.regexp(r"^/admin_set_plan\s+\d+\s+\w+(\s+\d+)?$"))
async def cmd_set_plan(message: types.Message, session: AsyncSession, user):
    if not _is_admin(user):
        await message.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    parts = message.text.split()
    # /admin_set_plan <company_id> <plan_code> [months]
    company_id = int(parts[1])
    plan_code = parts[2]
    months = int(parts[3]) if len(parts) > 3 else 1

    sub = await set_plan_for_company(session, company_id, plan_code, months)
    await message.answer(
        f"‚úÖ –î–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {company_id} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–ª–∞–Ω '{plan_code}'. "
        f"–î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ {sub.expires_at:%Y-%m-%d}."
    )


@router.message(F.text.regexp(r"^/admin_pause\s+\d+$"))
async def cmd_pause(message: types.Message, session: AsyncSession, user):
    if not _is_admin(user):
        await message.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    company_id = int(message.text.split()[1])
    ok = await pause_subscription(session, company_id)
    await message.answer(
        "‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∞ –Ω–∞ –ø–∞—É–∑—É." if ok else "‚ÑπÔ∏è –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞."
    )


@router.message(F.text.regexp(r"^/admin_resume\s+\d+$"))
async def cmd_resume(message: types.Message, session: AsyncSession, user):
    if not _is_admin(user):
        await message.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    company_id = int(message.text.split()[1])
    ok = await resume_subscription(session, company_id)
    await message.answer(
        "‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∞." if ok else "‚ÑπÔ∏è –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞."
    )


@router.message(F.text.regexp(r"^/admin_cancel\s+\d+$"))
async def cmd_cancel(message: types.Message, session: AsyncSession, user):
    if not _is_admin(user):
        await message.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    company_id = int(message.text.split()[1])
    ok = await cancel_subscription(session, company_id)
    await message.answer("‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞." if ok else "‚ÑπÔ∏è –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")


@router.message(F.text.regexp(r"^/admin_company_status\s+\d+$"))
async def cmd_company_status(message: types.Message, session: AsyncSession, user):
    if not _is_admin(user):
        await message.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
        return
    company_id = int(message.text.split()[1])
    st = await get_company_subscription_status(session, company_id)
    trial, sub = st["trial"], st["subscription"]

    trial_info = "‚Äî"
    if trial["exists"]:
        trial_info = f"{fmt_date(trial['starts_at'])} ‚Üí {fmt_date(trial['expires_at'])}"

    sub_info = "‚Äî"
    if sub["exists"]:
        sub_info = f"{sub['status']} ({fmt_date(sub['starts_at'])} ‚Üí {fmt_date(sub['expires_at'])})"

    txt = [
        f"üè¢ –ö–æ–º–ø–∞–Ω–∏—è {company_id}",
        f"–î–æ—Å—Ç—É–ø: {'–¥–æ—Å—Ç—É–ø–µ–Ω' if st['available'] else '–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω'}",
        f"Trial: {'–∞–∫—Ç–∏–≤–µ–Ω' if trial.get('is_active') else '–Ω–µ—Ç'} ({trial_info})",
        f"–ü–æ–¥–ø–∏—Å–∫–∞: {sub.get('status') or '–Ω–µ—Ç'} ({sub_info})",
    ]
    await message.answer("\n".join(txt))


# --- File: handlers/important_stuff.py ---

from aiogram import Router, types
from aiogram.filters import Command
from sqlalchemy.ext.asyncio import AsyncSession
from utils.decorators import require_active_subscription

router = Router(name="important_stuff")


@router.message(Command("important"))
@require_active_subscription()
async def cmd_important(message: types.Message, session: AsyncSession, **kwargs):
    await message.answer("‚úÖ –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ —Å –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–æ–π")


# --- File: handlers/payments.py ---

from aiogram import Router, types
from aiogram.filters import Command
from services.payments import create_payment_link

router = Router(name="payments")


@router.message(Command("buy"))
async def cmd_buy(message: types.Message, user):
    if not user.company_id:
        await message.answer(
            "‚õî –°–Ω–∞—á–∞–ª–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç–µ—Å—å –∫ –∫–æ–º–ø–∞–Ω–∏–∏: /create_company –∏–ª–∏ /join <id>."
        )
        return

    link = await create_payment_link(
        company_id=user.company_id, plan_code="pro", months=1
    )
    await message.answer(f"–î–ª—è –æ–ø–ª–∞—Ç—ã –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ:\n{link}")


# --- File: handlers/admin.py ---

# handlers/admin.py
import logging
import json
from aiogram import Router, types
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from utils.enums import UserRole
from models.audit_log import AuditLog
from aiogram.filters import Command

router = Router(name="admin")
logger = logging.getLogger(__name__)


# –ò–∑–º–µ–Ω–µ–Ω –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä –Ω–∞ Command
@router.message(Command("list_companies"))
async def list_companies_cmd(message: types.Message, session: AsyncSession, user):
    if user.role != UserRole.admin.value:
        await message.answer("‚õî –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        return

    await message.answer("‚ö†Ô∏è –ö–æ–º–∞–Ω–¥–∞ /list_companies –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.")


# –ò–∑–º–µ–Ω–µ–Ω –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä –Ω–∞ Command
@router.message(Command("force_plan"))
async def force_plan_cmd(message: types.Message, session: AsyncSession, user):
    if user.role != UserRole.admin.value:
        await message.answer("‚õî –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        return

    await message.answer("‚ö†Ô∏è –ö–æ–º–∞–Ω–¥–∞ /force_plan –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.")


# –ò–∑–º–µ–Ω–µ–Ω –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä –Ω–∞ Command
@router.message(Command("audit_last"))
async def audit_last_cmd(message: types.Message, session: AsyncSession, user):
    if user.role != UserRole.admin.value:
        await message.answer("‚õî –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        return

    result = await session.execute(
        select(AuditLog).order_by(AuditLog.id.desc()).limit(5)
    )
    rows = result.scalars().all()

    if not rows:
        await message.answer("üì≠ –õ–æ–≥–∏ –ø—É—Å—Ç—ã")
        return

    text = "üìã <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ 5 –∑–∞–ø–∏—Å–µ–π audit_log:</b>\n\n"

    for row in rows:
        try:
            payload_str = json.dumps(row.payload, indent=2, ensure_ascii=False)
        except Exception:
            payload_str = str(row.payload)

        if len(payload_str) > 300:
            payload_str = payload_str[:300] + "‚Ä¶"

        text += (
            f"<b>ID:</b> {row.id}\n"
            f"<b>UserID:</b> {row.actor_user_id}, <b>TG:</b> {row.actor_tg_id}\n"
            f"<b>Action:</b> {row.action}\n"
            f"<b>Entity:</b> {row.entity_type}({row.entity_id})\n"
            f"<b>Payload:</b>\n<pre>{payload_str}</pre>\n"
            f"<b>Time:</b> {row.created_at}\n"
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        )

    await message.answer(text, parse_mode="HTML")


# --- File: handlers/__init__.py ---

# –û—Å—Ç–∞–≤—å—Ç–µ —ç—Ç–æ—Ç —Ñ–∞–π–ª –ø—É—Å—Ç—ã–º. –ù–∏–∫–∞–∫–∏—Ö –∏–º–ø–æ—Ä—Ç–æ–≤!


# --- File: models/file.py ---

from sqlalchemy import Column, BigInteger, String, ForeignKey
from sqlalchemy.orm import relationship
from .base import Base, TimestampMixin


class File(Base, TimestampMixin):
    __tablename__ = "files"

    id = Column(BigInteger, primary_key=True, autoincrement=True)

    task_id = Column(
        BigInteger, ForeignKey("tasks.id", ondelete="CASCADE"), nullable=False
    )
    company_id = Column(
        BigInteger,
        ForeignKey("companies.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    uploader_id = Column(
        BigInteger, ForeignKey("users.id", ondelete="SET NULL"), nullable=True
    )

    s3_key = Column(String, unique=True, nullable=False)
    original_name = Column(String, nullable=False)
    size = Column(BigInteger, nullable=False)
    mime_type = Column(String, nullable=False)

    # –°–≤—è–∑–∏
    task = relationship("Task", back_populates="files")
    uploader = relationship("User", back_populates="files")
    company = relationship("Company", back_populates="files")


# --- File: models/user.py ---

from sqlalchemy import Column, BigInteger, ForeignKey, DateTime, Enum, Boolean, text
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .base import Base
from utils.enums import UserRole


class User(Base):
    __tablename__ = "users"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    tg_id = Column(BigInteger, unique=True, nullable=False)
    role = Column(Enum(UserRole, name="user_role", native_enum=True), nullable=False)

    company_id = Column(
        BigInteger, ForeignKey("companies.id", ondelete="CASCADE"), nullable=True
    )
    phone_number = Column(BigInteger, nullable=True)

    is_active = Column(Boolean, server_default=text("true"), nullable=False)
    deleted_at = Column(DateTime(timezone=True), nullable=True)

    created_at = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    # –°–≤—è–∑–∏
    company = relationship("Company", back_populates="users")
    tasks = relationship("Task", back_populates="user")
    files = relationship("File", back_populates="uploader")
    sessions = relationship(
        "Session", back_populates="user", cascade="all, delete-orphan"
    )


# --- File: models/project.py ---

from sqlalchemy import Column, BigInteger, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from .base import Base, TimestampMixin


class Project(Base, TimestampMixin):
    __tablename__ = "projects"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    company_id = Column(
        BigInteger,
        ForeignKey("companies.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )

    deleted_at = Column(DateTime(timezone=True), nullable=True)

    company = relationship("Company", back_populates="projects")
    tasks = relationship("Task", back_populates="project", cascade="all, delete-orphan")


# --- File: models/task.py ---

from sqlalchemy import Column, BigInteger, String, ForeignKey, Enum, Text, DateTime
from sqlalchemy.orm import relationship
from .base import Base, TimestampMixin
from utils.enums import TaskStatus


class Task(Base, TimestampMixin):
    __tablename__ = "tasks"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    title = Column(String, nullable=False)
    description = Column(Text, nullable=True)

    status = Column(
        Enum(TaskStatus, name="taskstatus", native_enum=True),
        nullable=False,
        server_default=TaskStatus.todo.value,
    )

    project_id = Column(
        BigInteger,
        ForeignKey("projects.id", ondelete="CASCADE"),
        nullable=True,
        index=True,
    )
    company_id = Column(
        BigInteger,
        ForeignKey("companies.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    user_id = Column(
        BigInteger,
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        index=True,
    )

    deleted_at = Column(DateTime(timezone=True), nullable=True)

    # –°–≤—è–∑–∏
    files = relationship("File", back_populates="task", cascade="all, delete-orphan")
    project = relationship(
        "Project", back_populates="tasks", passive_deletes=True
    )  # ‚úÖ –¥–æ–±–∞–≤–ª–µ–Ω–æ passive_deletes=True
    user = relationship(
        "User", back_populates="tasks", passive_deletes=True
    )  # ‚úÖ –¥–æ–±–∞–≤–ª–µ–Ω–æ passive_deletes=True
    company = relationship("Company", back_populates="tasks", passive_deletes=True)


# --- File: models/company.py ---

from sqlalchemy import Column, BigInteger, String
from sqlalchemy.orm import relationship
from .base import Base


class Company(Base):
    __tablename__ = "companies"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)

    created_by = Column(BigInteger, nullable=True)

    # –°–≤—è–∑–∏
    users = relationship("User", back_populates="company", cascade="all, delete-orphan")
    projects = relationship(
        "Project", back_populates="company", cascade="all, delete-orphan"
    )
    files = relationship("File", back_populates="company", cascade="all, delete-orphan")
    trials = relationship(
        "Trial", back_populates="company", cascade="all, delete-orphan"
    )
    subscriptions = relationship(
        "Subscription", back_populates="company", cascade="all, delete-orphan"
    )
    tasks = relationship("Task", back_populates="company", cascade="all, delete-orphan")


# --- File: models/subscription.py ---

from sqlalchemy import Column, BigInteger, DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import ENUM
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base
from utils.enums import SubscriptionStatus


class Subscription(Base):
    __tablename__ = "subscriptions"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    company_id = Column(
        BigInteger,
        ForeignKey("companies.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    plan_id = Column(
        BigInteger, ForeignKey("plans.id", ondelete="CASCADE"), nullable=False
    )

    status = Column(
        ENUM(SubscriptionStatus, name="subscription_status", native_enum=True),
        nullable=False,
        server_default=SubscriptionStatus.trial.value,
    )
    starts_at = Column(DateTime(timezone=True), nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=True)

    created_at = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    created_by = Column(BigInteger, nullable=True)
    updated_by = Column(BigInteger, nullable=True)

    # –°–≤—è–∑–∏
    company = relationship("Company", back_populates="subscriptions")
    plan = relationship("Plan", back_populates="subscriptions")

    creator = relationship(
        "User", primaryjoin="Subscription.created_by==foreign(User.id)", viewonly=True
    )
    updater = relationship(
        "User", primaryjoin="Subscription.updated_by==foreign(User.id)", viewonly=True
    )


# --- File: models/trial.py ---

from sqlalchemy import Column, BigInteger, DateTime, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base


class Trial(Base):
    __tablename__ = "trials"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    company_id = Column(
        BigInteger, ForeignKey("companies.id", ondelete="CASCADE"), nullable=False
    )

    starts_at = Column(
        DateTime(timezone=True), nullable=False, server_default=func.now()
    )
    expires_at = Column(DateTime(timezone=True))
    is_active = Column(Boolean, nullable=False, server_default="true")

    created_at = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    created_by = Column(BigInteger, nullable=True)
    updated_by = Column(BigInteger, nullable=True)

    company = relationship("Company", back_populates="trials")


# --- File: models/plan.py ---

from sqlalchemy import Column, BigInteger, String, Integer
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship
from .base import Base


class Plan(Base):
    __tablename__ = "plans"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    code = Column(String(50), unique=True, nullable=False)
    name = Column(String, nullable=False)
    monthly_price = Column(Integer, nullable=False)
    period_days = Column(Integer, nullable=False)
    features = Column(JSONB, nullable=True, default=dict)

    subscriptions = relationship(
        "Subscription", back_populates="plan", cascade="all, delete-orphan"
    )
    invoices = relationship(
        "Invoice", back_populates="plan", cascade="all, delete-orphan"
    )


# --- File: models/session.py ---

# models/session.py
from sqlalchemy import Column, BigInteger, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base


class Session(Base):
    __tablename__ = "sessions"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    user_id = Column(
        BigInteger, ForeignKey("users.id", ondelete="CASCADE"), nullable=False
    )

    refresh_token = Column(String(255), unique=True, nullable=False)
    device_info = Column(String(255), nullable=True)
    ip_address = Column(String(50), nullable=True)
    expires_at = Column(DateTime(timezone=True), nullable=False)

    created_at = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    user = relationship("User", back_populates="sessions")


# --- File: models/invoice.py ---

from sqlalchemy import Column, BigInteger, String, Numeric, Enum, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base
import enum


class InvoiceStatus(str, enum.Enum):
    pending = "pending"
    paid = "paid"
    failed = "failed"


class Invoice(Base):
    __tablename__ = "invoices"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    company_id = Column(
        BigInteger,
        ForeignKey("companies.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    plan_id = Column(
        BigInteger,
        ForeignKey("plans.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )

    amount = Column(Numeric(10, 2), nullable=False)
    currency = Column(String(3), nullable=False, server_default="USD")
    status = Column(
        Enum(InvoiceStatus, name="invoice_status", native_enum=True),
        nullable=False,
        server_default=InvoiceStatus.pending.value,
    )

    created_at = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    # –°–≤—è–∑–∏
    company = relationship("Company", backref="invoices")
    plan = relationship("Plan", back_populates="invoices")
    payments = relationship(
        "Payment", back_populates="invoice", cascade="all, delete-orphan"
    )


# --- File: models/payment.py ---

from sqlalchemy import Column, BigInteger, String, Numeric, Enum, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base
from .invoice import InvoiceStatus


class Payment(Base):
    __tablename__ = "payments"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    invoice_id = Column(
        BigInteger,
        ForeignKey("invoices.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )

    amount = Column(Numeric(10, 2), nullable=False)
    currency = Column(String(3), nullable=False, server_default="USD")
    status = Column(
        Enum(InvoiceStatus, name="payment_status", native_enum=True),
        nullable=False,
        server_default=InvoiceStatus.pending.value,
    )

    created_at = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    # –°–≤—è–∑–∏
    invoice = relationship("Invoice", back_populates="payments")


# --- File: models/base.py ---

# models/base.py
from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, DateTime, func


class TimestampMixin:
    created_at = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )


Base = declarative_base()


# --- File: models/__init__.py ---

# models/__init__.py
from .base import Base
from .user import User
from .company import Company
from .project import Project
from .task import Task
from .file import File
from .trial import Trial
from .plan import Plan
from .subscription import Subscription
from .session import Session
from .invoice import Invoice
from .payment import Payment
from .audit_log import AuditLog

__all__ = [
    "Base",
    "User",
    "Company",
    "Project",
    "Task",
    "File",
    "Trial",
    "Plan",
    "Subscription",
    "Session",
    "Invoice",
    "Payment",
    "AuditLog",
]


# --- File: models/audit_log.py ---

from sqlalchemy import Column, BigInteger, String, DateTime, JSON
from sqlalchemy.sql import func
from .base import Base


class AuditLog(Base):
    __tablename__ = "audit_logs"

    id = Column(BigInteger, primary_key=True, autoincrement=True)
    actor_user_id = Column(BigInteger, nullable=True)
    actor_tg_id = Column(BigInteger, nullable=True)
    action = Column(String(255), nullable=False)
    entity_type = Column(String(100), nullable=True)
    entity_id = Column(BigInteger, nullable=True)
    payload = Column(JSON, nullable=True)
    created_at = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )


# --- File: services/companies.py ---

from datetime import datetime, timedelta, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from models.company import Company
from models.user import User
from models.trial import Trial
from utils.enums import UserRole
from config import TRIAL_DAYS_DEFAULT

UTC = timezone.utc


async def create_company(session: AsyncSession, name: str, created_by: int) -> Company:
    """–°–æ–∑–¥–∞—ë—Ç –∫–æ–º–ø–∞–Ω–∏—é –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ç—Ä–∏–∞–ª –≤ –æ–¥–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏."""
    company = Company(name=name, created_by=created_by)
    session.add(company)
    await session.flush()  # –ø–æ–ª—É—á–∞–µ–º company.id

    # –°—Ç–∞—Ä—Ç—É–µ–º —Ç—Ä–∏–∞–ª
    trial = Trial(
        company_id=company.id,
        starts_at=datetime.now(UTC),
        expires_at=datetime.now(UTC) + timedelta(days=TRIAL_DAYS_DEFAULT),
        is_active=True,
        created_by=created_by,
    )
    session.add(trial)

    # –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º —Å–æ–∑–¥–∞—Ç–µ–ª—è –∫ –∫–æ–º–ø–∞–Ω–∏–∏
    user = await session.get(User, created_by)
    if user:
        user.company_id = company.id
        user.role = UserRole.manager  # <- –≤–ª–∞–¥–µ–ª–µ—Ü –∫–æ–º–ø–∞–Ω–∏–∏
        session.add(user)

    await session.flush()
    return company


async def get_company_by_name(session: AsyncSession, name: str) -> Company | None:
    q = await session.execute(select(Company).where(Company.name == name))
    return q.scalar_one_or_none()


async def get_company_by_id(session: AsyncSession, company_id: int) -> Company | None:
    return await session.get(Company, company_id)


async def join_company(
    session: AsyncSession,
    user: User,
    company: Company,
    role: UserRole = UserRole.worker,
) -> User:
    """–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫ –∫–æ–º–ø–∞–Ω–∏–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π —Ä–æ–ª—å—é (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é WORKER)."""
    user.company_id = company.id
    user.role = role
    session.add(user)
    await session.flush()
    return user


# --- File: services/projects.py ---

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from models.project import Project


async def create_project(session: AsyncSession, name: str, company_id: int) -> Project:
    try:
        new_project = Project(name=name, company_id=company_id)
        session.add(new_project)
        await session.flush()
        await session.commit()  # –î–æ–±–∞–≤–ª–µ–Ω –∫–æ–º–º–∏—Ç
        await session.refresh(new_project)  # –î–æ–±–∞–≤–ª–µ–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞
        return new_project
    except Exception as e:
        await session.rollback()  # –î–æ–±–∞–≤–ª–µ–Ω –æ—Ç–∫–∞—Ç –ø—Ä–∏ –æ—à–∏–±–∫–µ
        raise e


async def get_projects_by_company_id(
    session: AsyncSession, company_id: int
) -> list[Project]:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ –ø—Ä–æ–µ–∫—Ç—ã –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏.
    """
    result = await session.execute(
        select(Project).filter(Project.company_id == company_id)
    )
    return result.scalars().all()


async def get_project_by_id_and_company(
    session: AsyncSession, project_id: int, company_id: int
) -> Project | None:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –ø—Ä–æ–µ–∫—Ç –ø–æ –µ–≥–æ ID, —É–±–µ–∂–¥–∞—è—Å—å, —á—Ç–æ –æ–Ω –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –Ω—É–∂–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏.
    """
    result = await session.execute(
        select(Project).filter(
            Project.id == project_id, Project.company_id == company_id
        )
    )
    return result.scalar_one_or_none()


# --- File: services/tasks.py ---

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from models.task import Task
from datetime import datetime, UTC
from typing import Optional


async def create_task(
    session: AsyncSession,
    title: str,
    description: str,
    project_id: int,
    company_id: int,
    user_id: int,
) -> Task:
    try:
        new_task = Task(
            title=title,
            description=description,
            project_id=project_id,
            company_id=company_id,
            user_id=user_id,
            created_at=datetime.now(UTC),
        )
        session.add(new_task)
        await session.flush()
        await session.commit()  # –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–º–º–∏—Ç
        await session.refresh(new_task)  # –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—ä–µ–∫—Ç
        return new_task
    except Exception as e:
        await session.rollback()
        raise e


async def get_task_by_id_and_company(
    session: AsyncSession, task_id: int, company_id: int
) -> Optional[Task]:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –∑–∞–¥–∞—á—É –ø–æ ID, —É–±–µ–∂–¥–∞—è—Å—å, —á—Ç–æ –æ–Ω–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –Ω—É–∂–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏.
    """
    result = await session.execute(
        select(Task).filter(Task.id == task_id, Task.company_id == company_id)
    )
    return result.scalar_one_or_none()


async def get_my_tasks(session: AsyncSession, user_id: int) -> list[Task]:
    """
    –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ –∑–∞–¥–∞—á–∏, –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–µ —Ç–µ–∫—É—â–µ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.
    """
    result = await session.execute(select(Task).where(Task.user_id == user_id))
    return result.scalars().all()


# --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: reassign_task ---
# –í–º–µ—Å—Ç–æ get_task_by_id (—É—è–∑–≤–∏–º–æ–π) –∏—Å–ø–æ–ª—å–∑—É–µ–º get_task_by_id_and_company (–±–µ–∑–æ–ø–∞—Å–Ω—É—é)
async def reassign_task(
    session: AsyncSession, task_id: int, new_user_id: int, company_id: int
) -> Optional[Task]:
    """
    –ü–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–∞–µ—Ç –∑–∞–¥–∞—á—É –¥—Ä—É–≥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç–∏ –∫ –∫–æ–º–ø–∞–Ω–∏–∏.
    """
    task = await get_task_by_id_and_company(
        session, task_id, company_id
    )  # <- –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é
    if task:
        task.user_id = new_user_id
        session.add(task)
    return task


# --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: set_task_status ---
# –¢–æ –∂–µ —Å–∞–º–æ–µ: –¥–æ–±–∞–≤–ª—è–µ–º company_id –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
async def set_task_status(
    session: AsyncSession, task_id: int, status: str, company_id: int
) -> Optional[Task]:
    """
    –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –¥–ª—è –∑–∞–¥–∞—á–∏, —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç–∏ –∫ –∫–æ–º–ø–∞–Ω–∏–∏.
    """
    task = await get_task_by_id_and_company(
        session, task_id, company_id
    )  # <- –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é
    if task:
        task.status = status
        session.add(task)
    return task


# --- File: services/users.py ---

# services/users.py
import logging
from datetime import datetime, UTC
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from models.user import User
from utils.enums import UserRole

logger = logging.getLogger(__name__)


async def get_or_create_user(session: AsyncSession, tg_id: int):
    q = select(User).where(User.tg_id == tg_id)
    res = await session.execute(q)
    user = res.scalar_one_or_none()
    if user:
        return user, False

    user = User(
        tg_id=tg_id,
        role=UserRole.client,  # ‚úÖ –ª—é–±–æ–µ –∏–∑ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö
        company_id=None,
        phone_number=None,
        created_at=datetime.now(UTC),
        updated_at=datetime.now(UTC),
    )
    session.add(user)
    await session.flush()  # –ø–æ–ª—É—á–∞–µ–º ID
    return user, True


async def get_user_by_tg_id(session: AsyncSession, tg_id: int):
    result = await session.execute(select(User).filter(User.tg_id == tg_id))
    return result.scalar_one_or_none()


async def set_user_role_and_company(
    session: AsyncSession, user_id: int, role: UserRole, company_id: int = None
):
    logger.debug(f"–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–æ–ª—å {role.name} –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")

    if not isinstance(role, UserRole):
        raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø —Ä–æ–ª–∏")

    user = await session.get(User, user_id)
    if not user:
        raise ValueError("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")

    if company_id in ("", None):
        user.company_id = None
    else:
        user.company_id = int(company_id)

    user.role = role
    await session.flush()
    return user


# --- File: services/reports.py ---

# services/reports.py
from sqlalchemy.ext.asyncio import AsyncSession
from models.user import User


async def get_user_report(session: AsyncSession, user: User) -> dict:
    # –ó–¥–µ—Å—å –≤ –±—É–¥—É—â–µ–º –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –¥–ª—è —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ –æ—Ç—á–µ—Ç–∞–º
    return {"completed_tasks": 0, "in_progress_tasks": 0}


# --- File: services/files.py ---

from sqlalchemy.ext.asyncio import AsyncSession
from models.file import File
import uuid
from typing import Optional
import logging

logger = logging.getLogger(__name__)


async def create_file(
    session: AsyncSession,
    task_id: int,
    company_id: int,  # <-- –î–æ–±–∞–≤–∏–ª–∏ —ç—Ç–æ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç
    uploader_id: int,
    original_name: str,
    mime_type: str,
    size: int,
    s3_key: str,
) -> File:
    """–°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å –æ —Ñ–∞–π–ª–µ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö.
    Args:
        session: –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Å–µ—Å—Å–∏—è SQLAlchemy.
        task_id: ID –∑–∞–¥–∞—á–∏, –∫ –∫–æ—Ç–æ—Ä–æ–π –ø—Ä–∏–≤—è–∑–∞–Ω —Ñ–∞–π–ª.
        company_id: ID –∫–æ–º–ø–∞–Ω–∏–∏, –∫ –∫–æ—Ç–æ—Ä–æ–π –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —Ñ–∞–π–ª.
        uploader_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–≥—Ä—É–∑–∏–ª —Ñ–∞–π–ª.
        original_name: –ò–º—è —Ñ–∞–π–ª–∞, –∫–æ—Ç–æ—Ä–æ–µ –±—ã–ª–æ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        mime_type: MIME-—Ç–∏–ø —Ñ–∞–π–ª–∞.
        size: –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ –±–∞–π—Ç–∞—Ö.
        s3_key: –ö–ª—é—á —Ñ–∞–π–ª–∞ –≤ S3-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ.
    """
    new_file = File(
        task_id=task_id,
        company_id=company_id,  # <-- –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç
        uploader_id=uploader_id,
        original_name=original_name,
        mime_type=mime_type,
        size=size,
        s3_key=s3_key,
    )
    session.add(new_file)
    # commit/flush –±—É–¥–µ—Ç —Å–¥–µ–ª–∞–Ω –≤ DbSessionMiddleware
    return new_file


async def get_file_by_id(session: AsyncSession, file_id: uuid.UUID) -> Optional[File]:
    """
    –ü–æ–ª—É—á–∞–µ—Ç —Ñ–∞–π–ª –ø–æ –µ–≥–æ UUID.
    """
    return await session.get(File, file_id)


async def delete_file(session: AsyncSession, file_id: uuid.UUID) -> bool:
    """
    –£–¥–∞–ª—è–µ—Ç –∑–∞–ø–∏—Å—å –æ —Ñ–∞–π–ª–µ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.

    Returns:
        True, –µ—Å–ª–∏ —Ñ–∞–π–ª –±—ã–ª –Ω–∞–π–¥–µ–Ω –∏ —É–¥–∞–ª–µ–Ω, False –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ.
    """
    file_to_delete = await get_file_by_id(session, file_id)
    if file_to_delete:
        await session.delete(file_to_delete)
        await session.commit()
        logger.info(f"File {file_id} deleted from database.")
        return True
    logger.warning(f"File {file_id} not found for deletion.")
    return False


# --- File: services/subscriptions.py ---

# services/subscription.py
import logging
from datetime import datetime, timedelta, timezone
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from utils.enums import SubscriptionStatus
from config import TRIAL_DAYS_DEFAULT
from models import Trial, Subscription, Plan, User


logger = logging.getLogger(__name__)

UTC = timezone.utc


class PermissionDenied(Exception):
    """–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏."""


# ---------- Trial ----------


async def _start_trial(
    session: AsyncSession,
    company_id: int,
    created_by: int | None = None,
    days: int = TRIAL_DAYS_DEFAULT,
) -> Trial:
    """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ö–µ–ª–ø–µ—Ä –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è trial (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ extend_trial)."""
    now = datetime.now(UTC)
    trial = Trial(
        company_id=company_id,
        starts_at=now,
        expires_at=now + timedelta(days=days),
        is_active=True,
        created_by=created_by,
    )
    session.add(trial)
    await session.flush()
    return trial


async def is_trial_active(session: AsyncSession, company_id: int) -> bool:
    q = await session.execute(select(Trial).where(Trial.company_id == company_id))
    t = q.scalar_one_or_none()
    if not t:
        return False
    return t.is_active and t.expires_at > datetime.now(UTC)


async def extend_trial(
    session: AsyncSession, company_id: int, extra_days: int
) -> Trial:
    q = await session.execute(select(Trial).where(Trial.company_id == company_id))
    trial = q.scalar_one_or_none()
    now = datetime.now(UTC)

    if not trial:
        # –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî —Å—Ç–∞—Ä—Ç—É–µ–º –Ω–æ–≤—ã–π –Ω–∞ extra_days
        trial = await _start_trial(
            session, company_id, days=extra_days or TRIAL_DAYS_DEFAULT
        )
    else:
        base = trial.expires_at if trial.expires_at and trial.expires_at > now else now
        trial.expires_at = base + timedelta(days=extra_days)
        trial.is_active = True
        await session.flush()
    return trial


# ---------- Subscriptions ----------


async def _get_plan(session: AsyncSession, plan_code: str) -> Plan | None:
    q = await session.execute(select(Plan).where(Plan.code == plan_code))
    return q.scalar_one_or_none()


async def start_paid_subscription(
    session: AsyncSession, company_id: int, plan_code: str, months: int = 1
) -> Subscription:
    """–ê–∫—Ç–∏–≤–∏—Ä—É–µ—Ç –ø–ª–∞—Ç–Ω—É—é –ø–æ–¥–ø–∏—Å–∫—É (–±–µ–∑ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –ø–ª–∞—Ç–µ–∂–∫–æ–π)."""
    plan = await _get_plan(session, plan_code)
    if not plan:
        raise ValueError(f"Plan '{plan_code}' not found")

    now = datetime.now(UTC)
    expires = now + timedelta(days=30 * months)

    sub = Subscription(
        company_id=company_id,
        plan_id=plan.id,
        status=SubscriptionStatus.active.value,
        starts_at=now,
        expires_at=expires,
    )
    session.add(sub)

    # –¢—Ä–∏–∞–ª –≤—ã–∫–ª—é—á–∞–µ–º, –µ—Å–ª–∏ –±—ã–ª
    q = await session.execute(select(Trial).where(Trial.company_id == company_id))
    t = q.scalar_one_or_none()
    if t and t.is_active:
        t.is_active = False

    await session.flush()
    logger.info(
        "–ü–æ–¥–ø–∏—Å–∫–∞: company_id=%s, plan=%s, months=%s, expires_at=%s",
        company_id,
        plan_code,
        months,
        sub.expires_at,
    )
    return sub


async def pause_subscription(session: AsyncSession, company_id: int) -> bool:
    q = await session.execute(
        select(Subscription)
        .where(Subscription.company_id == company_id)
        .order_by(Subscription.expires_at.desc())
    )
    sub = q.scalars().first()
    if not sub:
        return False
    sub.status = SubscriptionStatus.paused.value
    await session.flush()
    return True


async def resume_subscription(session: AsyncSession, company_id: int) -> bool:
    q = await session.execute(
        select(Subscription)
        .where(Subscription.company_id == company_id)
        .order_by(Subscription.expires_at.desc())
    )
    sub = q.scalars().first()
    if not sub:
        return False
    sub.status = SubscriptionStatus.active.value
    await session.flush()
    return True


async def cancel_subscription(session: AsyncSession, company_id: int) -> bool:
    q = await session.execute(
        select(Subscription)
        .where(Subscription.company_id == company_id)
        .order_by(Subscription.expires_at.desc())
    )
    sub = q.scalars().first()
    if not sub:
        return False
    sub.status = SubscriptionStatus.canceled.value
    await session.flush()
    return True


async def mark_expired_if_needed(session: AsyncSession, company_id: int) -> bool:
    """–ï—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–∞ ‚Äî —Å—Ç–∞–≤–∏–º expired."""
    q = await session.execute(
        select(Subscription)
        .where(Subscription.company_id == company_id)
        .order_by(Subscription.expires_at.desc())
    )
    sub = q.scalars().first()
    if not sub:
        return False
    now = datetime.now(UTC)
    if sub.status == SubscriptionStatus.active.value and sub.expires_at <= now:
        sub.status = SubscriptionStatus.expired.value
        await session.flush()
        return True
    return False


async def has_active_subscription_for_user(session: AsyncSession, user_id: int) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞ (trial –∏–ª–∏ –ø–ª–∞—Ç–Ω–∞—è).
    """
    # –ù–∞—Ö–æ–¥–∏–º –∫–æ–º–ø–∞–Ω–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    q_user = await session.execute(select(User).where(User.id == user_id))
    user = q_user.scalar_one_or_none()
    if not user or not user.company_id:
        return False

    company_id = user.company_id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º trial
    q_trial = await session.execute(select(Trial).where(Trial.company_id == company_id))
    trial = q_trial.scalar_one_or_none()
    if trial and trial.is_active and trial.expires_at > datetime.now(UTC):
        return True

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É
    q_sub = await session.execute(
        select(Subscription)
        .where(Subscription.company_id == company_id)
        .order_by(Subscription.expires_at.desc())
    )
    sub = q_sub.scalars().first()
    if (
        sub
        and sub.status == SubscriptionStatus.active.value
        and sub.expires_at > datetime.now(UTC)
    ):
        return True

    return False


# ---------- Helpers ----------


async def set_plan_for_company(
    session: AsyncSession, company_id: int, plan_code: str, months: int = 1
) -> Subscription:
    """–ê–¥–º–∏–Ω—Å–∫–∏–π —Ö–µ–ª–ø–µ—Ä –±–µ–∑ –ø–ª–∞—Ç–µ–∂–µ–π ‚Äî –ø—Ä–æ—Å—Ç–æ –≤—ã–¥–∞—Ç—å –ø–ª–∞—Ç–Ω—ã–π –ø–µ—Ä–∏–æ–¥."""
    return await start_paid_subscription(
        session, company_id, plan_code=plan_code, months=months
    )


async def get_company_subscription_status(
    session: AsyncSession, company_id: int
) -> dict:
    """–°–≤–æ–¥–Ω—ã–π —Å—Ç–∞—Ç—É—Å –¥–æ—Å—Ç—É–ø–∞: trial/subscription/available."""
    # trial
    q_t = await session.execute(select(Trial).where(Trial.company_id == company_id))
    t = q_t.scalar_one_or_none()

    # last subscription
    q_s = await session.execute(
        select(Subscription)
        .where(Subscription.company_id == company_id)
        .order_by(Subscription.expires_at.desc())
    )
    s = q_s.scalars().first()

    trial_active = bool(t and t.is_active and t.expires_at > datetime.now(UTC))
    sub_active = bool(
        s
        and s.status == SubscriptionStatus.active.value
        and s.expires_at > datetime.now(UTC)
    )

    return {
        "available": trial_active or sub_active,
        "trial": {
            "exists": bool(t),
            "is_active": trial_active,
            "starts_at": getattr(t, "starts_at", None),
            "expires_at": getattr(t, "expires_at", None),
        },
        "subscription": {
            "exists": bool(s),
            "status": getattr(s, "status", None),
            "starts_at": getattr(s, "starts_at", None),
            "expires_at": getattr(s, "expires_at", None),
            "plan_id": getattr(s, "plan_id", None),
        },
    }


# –ê–ª–∏–∞—Å –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
async def create_subscription(
    session, company_id, plan_code, actor_id=None, commit=True
):
    """
    –°—Ç–∞—Ä—ã–π –∞–ª–∏–∞—Å –¥–ª—è set_plan_for_company, –æ—Å—Ç–∞–≤–ª–µ–Ω –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏.
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç actor_id –∏ commit, —Ö–æ—Ç—è set_plan_for_company –∏—Ö –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç.
    """
    sub = await set_plan_for_company(
        session=session,
        company_id=company_id,
        plan_code=plan_code,
        months=1,  # –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    )
    if commit:
        await session.commit()
    return sub


async def get_active_subscription(session, company_id):
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–∫—Ç–∏–≤–Ω—É—é –ø–æ–¥–ø–∏—Å–∫—É –∫–æ–º–ø–∞–Ω–∏–∏ (–∏–ª–∏ None)."""
    status = await get_company_subscription_status(session, company_id)
    if (
        status["subscription"]["exists"]
        and status["subscription"]["status"] == "active"
    ):
        return status["subscription"]
    return None


# --- File: services/notify_jobs.py ---

from datetime import datetime, timedelta, timezone
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram import Bot
from models import Trial, Subscription, User
from utils.enums import UserRole, SubscriptionStatus
from config import BILLING_REMIND_DAYS

import logging

UTC = timezone.utc
logger = logging.getLogger(__name__)


async def _company_admins_and_managers(session: AsyncSession, company_id: int):
    """–ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –∞–¥–º–∏–Ω–æ–≤ –∏ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –∫–æ–º–ø–∞–Ω–∏–∏"""
    q = await session.execute(
        select(User).where(
            User.company_id == company_id,
            User.role.in_([UserRole.ADMIN.value, UserRole.MANAGER.value]),
        )
    )
    return q.scalars().all()


async def notify_expiring_trials(session: AsyncSession, bot: Bot):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ç–æ–º, —á—Ç–æ —Ç—Ä–∏–∞–ª —Å–∫–æ—Ä–æ –∑–∞–∫–æ–Ω—á–∏—Ç—Å—è"""
    now = datetime.now(UTC)
    target = now + timedelta(days=BILLING_REMIND_DAYS)

    q = await session.execute(
        select(Trial).where(Trial.is_active, Trial.expires_at.between(now, target))
    )

    for trial in q.scalars().all():
        managers = await _company_admins_and_managers(session, trial.company_id)
        for u in managers:
            try:
                await bot.send_message(
                    u.tg_id,
                    f"‚ö†Ô∏è –£ –∫–æ–º–ø–∞–Ω–∏–∏ #{trial.company_id} —Ç—Ä–∏–∞–ª –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è {trial.expires_at:%Y-%m-%d}. "
                    f"–ü—Ä–æ–¥–ª–∏—Ç–µ –∏–ª–∏ –æ—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É.",
                )
            except Exception as e:
                logger.warning(
                    f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {u.tg_id}: {e}"
                )


async def notify_expiring_subscriptions(session: AsyncSession, bot: Bot):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ç–æ–º, —á—Ç–æ –ø–æ–¥–ø–∏—Å–∫–∞ —Å–∫–æ—Ä–æ –∑–∞–∫–æ–Ω—á–∏—Ç—Å—è"""
    now = datetime.now(UTC)
    target = now + timedelta(days=BILLING_REMIND_DAYS)

    q = await session.execute(
        select(Subscription).where(
            Subscription.status == SubscriptionStatus.active.value,
            Subscription.expires_at.between(now, target),
        )
    )

    for sub in q.scalars().all():
        managers = await _company_admins_and_managers(session, sub.company_id)
        for u in managers:
            try:
                await bot.send_message(
                    u.tg_id,
                    f"‚ö†Ô∏è –ü–æ–¥–ø–∏—Å–∫–∞ –∫–æ–º–ø–∞–Ω–∏–∏ #{sub.company_id} –∏—Å—Ç–µ–∫–∞–µ—Ç {sub.expires_at:%Y-%m-%d}. "
                    f"–û–ø–ª–∞—Ç–∏—Ç–µ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.",
                )
            except Exception as e:
                logger.warning(
                    f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {u.tg_id}: {e}"
                )


async def enforce_expirations(session: AsyncSession, bot: Bot):
    """–í –¥–µ–Ω—å –æ–∫–æ–Ω—á–∞–Ω–∏—è: –æ—Ç–∫–ª—é—á–∞–µ–º —Ç—Ä–∏–∞–ª –∏ –ø–æ–¥–ø–∏—Å–∫—É"""
    now = datetime.now(UTC)

    # —Ç—Ä–∏–∞–ª—ã
    q_t = await session.execute(
        select(Trial).where(Trial.is_active, Trial.expires_at <= now)
    )
    for t in q_t.scalars().all():
        t.is_active = False
        managers = await _company_admins_and_managers(session, t.company_id)
        for u in managers:
            try:
                await bot.send_message(
                    u.tg_id,
                    f"‚õî –¢—Ä–∏–∞–ª –∫–æ–º–ø–∞–Ω–∏–∏ #{t.company_id} –∑–∞–≤–µ—Ä—à—ë–Ω. –î–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.",
                )
            except Exception as e:
                logger.warning(
                    f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {u.tg_id}: {e}"
                )

    # –ø–æ–¥–ø–∏—Å–∫–∏
    q_s = await session.execute(
        select(Subscription).where(
            Subscription.status == SubscriptionStatus.active.value,
            Subscription.expires_at <= now,
        )
    )
    for s in q_s.scalars().all():
        s.status = SubscriptionStatus.expired.value
        managers = await _company_admins_and_managers(session, s.company_id)
        for u in managers:
            try:
                await bot.send_message(
                    u.tg_id,
                    f"‚õî –ü–æ–¥–ø–∏—Å–∫–∞ –∫–æ–º–ø–∞–Ω–∏–∏ #{s.company_id} –∏—Å—Ç–µ–∫–ª–∞. –î–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.",
                )
            except Exception as e:
                logger.warning(
                    f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {u.tg_id}: {e}"
                )


async def run_all(session: AsyncSession, bot: Bot):
    """–ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –∑–∞–¥–∞—á –ø–æ–¥—Ä—è–¥"""
    await notify_expiring_trials(session, bot)
    await notify_expiring_subscriptions(session, bot)
    await enforce_expirations(session, bot)


# --- File: services/payments.py ---

# services/payments.py
from datetime import timezone
from sqlalchemy.ext.asyncio import AsyncSession
from services.subscriptions import start_paid_subscription

UTC = timezone.utc


async def create_payment_link(company_id: int, plan_code: str, months: int = 1) -> str:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É (–ø–æ–∫–∞ —Ñ–µ–π–∫–æ–≤–∞—è).
    –í –±—É–¥—É—â–µ–º —Ç—É—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å YooKassa –∏–ª–∏ Tinkoff.
    """
    return f"https://fake-payments.local/pay?company={company_id}&plan={plan_code}&months={months}"


async def handle_payment_webhook(
    session: AsyncSession, company_id: int, plan_code: str, months: int = 1
):
    """
    –ó–∞–≥–ª—É—à–∫–∞ –ø–æ–¥ –≤–µ–±—Ö—É–∫ –æ—Ç YooKassa/Tinkoff.
    –ö–æ–≥–¥–∞ –ø–ª–∞—Ç—ë–∂ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω ‚Äî –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∫—É.
    """
    sub = await start_paid_subscription(session, company_id, plan_code, months)
    return sub


# –ü–æ–∑–∂–µ —Å—é–¥–∞ –ª–µ–≥–∫–æ –ø—Ä–∏–∫—Ä—É—Ç–∏—Ç—å yookassa SDK –∏–ª–∏ API Tinkoff.


# --- File: services/import_export.py ---

# services/import_export.py
import csv
import sqlalchemy as sa
from models import User


async def export_users(session, filepath: str):
    users = await session.execute(sa.select(User))
    with open(filepath, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(
            ["id", "tg_id", "email", "phone_number", "role", "created_at", "updated_at"]
        )
        for u in users.scalars():
            writer.writerow(
                [
                    u.id,
                    u.tg_id,
                    u.email,
                    u.phone_number,
                    u.role,
                    u.created_at,
                    u.updated_at,
                ]
            )


async def import_users(session, filepath: str):
    with open(filepath, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            user = User(**row)
            session.add(user)
    await session.commit()


# --- File: services/audit.py ---

import logging
from models.audit_log import AuditLog

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –±–∞–∑–æ–≤–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)

# –°–æ–∑–¥–∞—ë–º –ª–æ–∫–∞–ª—å–Ω—ã–π –ª–æ–≥–≥–µ—Ä
logger = logging.getLogger(__name__)


async def log_action(
    session,
    actor_user_id,
    actor_tg_id,
    action,
    entity_type=None,
    entity_id=None,
    payload=None,
):
    if not action:
        raise ValueError("–î–µ–π—Å—Ç–≤–∏–µ (action) –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")

    try:
        log = AuditLog(
            actor_user_id=actor_user_id,
            actor_tg_id=actor_tg_id,
            action=action,
            entity_type=entity_type,
            entity_id=entity_id,
            payload=payload,
        )
        session.add(log)
        await session.flush()
        logger.info(
            f"–£—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ: {action} –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {actor_user_id}"
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–∏: {str(e)}")
        raise


# --- File: services/test_s3.py ---

# scripts/test_s3.py
import asyncio
from storage.s3 import generate_presigned_put_url, generate_presigned_get_url
import aiohttp
import uuid


async def main():
    # –ì–µ–Ω–µ—Ä–∏–º —Å–ª—É—á–∞–π–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
    object_name = f"test/{uuid.uuid4()}.txt"

    # –ü–æ–ª—É—á–∞–µ–º URL –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏
    put_url = await generate_presigned_put_url(object_name)
    print("PUT URL:", put_url)

    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª —á–µ—Ä–µ–∑ aiohttp
    async with aiohttp.ClientSession() as session:
        async with session.put(put_url, data=b"Hello from test_s3!") as resp:
            print("Upload status:", resp.status)

    # –ü–æ–ª—É—á–∞–µ–º URL –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
    get_url = await generate_presigned_get_url(object_name)
    print("GET URL:", get_url)

    # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
    async with aiohttp.ClientSession() as session:
        async with session.get(get_url) as resp:
            data = await resp.text()
            print("Downloaded content:", data)


if __name__ == "__main__":
    asyncio.run(main())


# --- File: utils/helpers.py ---

# utils/helpers.py
from datetime import datetime
from models.project import Project
from models.task import Task


def format_project_list(projects: list[Project]) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–µ–∫—Ç–æ–≤ –≤ —á–∏—Ç–∞–µ–º—ã–π —Ç–µ–∫—Å—Ç.
    """
    if not projects:
        return "–ü—Ä–æ–µ–∫—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã."

    formatted_list = [f"{p.id}. {p.name}" for p in projects]
    return "–°–ø–∏—Å–æ–∫ –ø—Ä–æ–µ–∫—Ç–æ–≤:\n" + "\n".join(formatted_list)


def format_tasks_list(tasks: list[Task]) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á –≤ —á–∏—Ç–∞–µ–º—ã–π —Ç–µ–∫—Å—Ç.
    """
    if not tasks:
        return "–ó–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã."

    text = "–°–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á:\n"
    for task in tasks:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—ä–µ–∫—Ç project —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫
        project_name = task.project.name if task.project else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–æ–µ–∫—Ç"
        text += f"\n–ó–∞–¥–∞—á–∞ ID: {task.id}\n"
        text += f"  - –ù–∞–∑–≤–∞–Ω–∏–µ: {task.title}\n"
        text += f"  - –ü—Ä–æ–µ–∫—Ç: {project_name}\n"
        text += f"  - –°—Ç–∞—Ç—É—Å: {task.status}\n"

    return text


def get_current_time_str() -> str:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –≤ —Å—Ç—Ä–æ–∫–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ.
    """
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


# --- File: utils/decorators.py ---

# utils/decorators.py
from functools import wraps
from aiogram.types import Message, CallbackQuery
from services.subscriptions import get_company_subscription_status

from utils.enums import UserRole


def is_manager(func):
    @wraps(func)
    async def wrapper(event: Message | CallbackQuery, *args, **kwargs):
        user = kwargs.get("user")
        if not user or user.role != UserRole.manager:
            await (
                event.answer if isinstance(event, Message) else event.message.answer
            )("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
            return
        return await func(event, *args, **kwargs)

    return wrapper


def is_manager_or_foreman(func):
    @wraps(func)
    async def wrapper(event: Message | CallbackQuery, *args, **kwargs):
        user = kwargs.get("user")
        if not user or user.role not in (UserRole.manager, UserRole.foreman):
            await (
                event.answer if isinstance(event, Message) else event.message.answer
            )("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
            return
        return await func(event, *args, **kwargs)

    return wrapper


def require_active_subscription():
    def decorator(func):
        @wraps(func)
        async def wrapper(event: Message | CallbackQuery, *args, **kwargs):
            # aiogram v3: –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –ø—Ä–∏—Ö–æ–¥—è—Ç –Ω–∞–ø—Ä—è–º—É—é –≤ kwargs
            session = kwargs.get("session")
            user = kwargs.get("user")

            if not user or not getattr(user, "company_id", None):
                if isinstance(event, Message):
                    await event.answer("‚õî –°–Ω–∞—á–∞–ª–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç–µ—Å—å –∫ –∫–æ–º–ø–∞–Ω–∏–∏.")
                else:
                    await event.answer(
                        "‚õî –°–Ω–∞—á–∞–ª–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç–µ—Å—å –∫ –∫–æ–º–ø–∞–Ω–∏–∏.", show_alert=True
                    )
                return

            st = await get_company_subscription_status(session, user.company_id)
            if not st["available"]:
                if isinstance(event, Message):
                    await event.answer("‚õî –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏.")
                else:
                    await event.answer("‚õî –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏.", show_alert=True)
                return

            return await func(event, *args, **kwargs)

        return wrapper

    return decorator


# --- File: utils/keyboards.py ---

from aiogram.types import (
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    ReplyKeyboardMarkup,
    KeyboardButton,
)


def get_role_selection_keyboard():
    buttons = [
        [
            InlineKeyboardButton(
                text="–†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å", callback_data="set_role:—Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å"
            ),
            InlineKeyboardButton(text="–ë—Ä–∏–≥–∞–¥–∏—Ä", callback_data="set_role:–±—Ä–∏–≥–∞–¥–∏—Ä"),
        ],
        [InlineKeyboardButton(text="–†–∞–±–æ—á–∏–π", callback_data="set_role:—Ä–∞–±–æ—á–∏–π")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_main_menu_keyboard() -> ReplyKeyboardMarkup:
    """
    –°–æ–∑–¥–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω–æ–µ –º–µ–Ω—é.
    """
    buttons = [
        [KeyboardButton(text="/projects"), KeyboardButton(text="/tasks")],
        [KeyboardButton(text="/reports")],
    ]
    return ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)


def get_task_status_keyboard():
    buttons = [
        [InlineKeyboardButton(text="–ù–∞–∑–Ω–∞—á–µ–Ω–æ", callback_data="status_assigned")],
        [InlineKeyboardButton(text="–í —Ä–∞–±–æ—Ç–µ", callback_data="status_in_progress")],
        [InlineKeyboardButton(text="–ó–∞–≤–µ—Ä—à–µ–Ω–æ", callback_data="status_done")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_tasks_keyboard(tasks):
    buttons = [
        [
            InlineKeyboardButton(
                text=f"–ó–∞–¥–∞—á–∞: {task.title}", callback_data=f"show_task:{task.id}"
            )
        ]
        for task in tasks
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_task_options_keyboard(task_id):
    buttons = [
        [
            InlineKeyboardButton(
                text="–í–∑—è—Ç—å –≤ —Ä–∞–±–æ—Ç—É", callback_data=f"take_task:{task_id}"
            )
        ],
        [
            InlineKeyboardButton(
                text="–ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data=f"complete_task:{task_id}"
            )
        ],
        [
            InlineKeyboardButton(
                text="–û—Ç–∫–∞–∑–∞—Ç—å—Å—è", callback_data=f"decline_task:{task_id}"
            )
        ],
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_company_management_keyboard():
    buttons = [
        [InlineKeyboardButton(text="–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", callback_data="add_user")],
        [InlineKeyboardButton(text="–ò–∑–º–µ–Ω–∏—Ç—å —Ä–æ–ª—å", callback_data="change_role")],
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_confirm_keyboard():
    buttons = [
        [
            InlineKeyboardButton(text="–î–∞", callback_data="confirm"),
            InlineKeyboardButton(text="–ù–µ—Ç", callback_data="cancel"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_project_creation_keyboard():
    buttons = [
        [
            InlineKeyboardButton(
                text="–°–æ–∑–¥–∞—Ç—å –ø—Ä–æ–µ–∫—Ç", callback_data="create_project_start"
            )
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


# --- File: utils/enums.py ---

import enum


class UserRole(str, enum.Enum):
    manager = "manager"  # –†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å ‚Äî —Å–æ–∑–¥–∞—ë—Ç –∫–æ–º–ø–∞–Ω–∏—é, –≤–∏–¥–∏—Ç –≤—Å—ë
    foreman = "foreman"  # –ë—Ä–∏–≥–∞–¥–∏—Ä / –ø—Ä–æ—Ä–∞–± ‚Äî –≤–µ–¥—ë—Ç –∑–∞–¥–∞—á–∏, –æ—Ç—á—ë—Ç—ã
    worker = "worker"  # –†–∞–±–æ—á–∏–π ‚Äî –∑–∞–¥–∞—á–∏, —Ñ–æ—Ç–æ, –æ—Ç—á—ë—Ç—ã
    client = "client"  # —Ä–æ–ª—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∞ (—ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç "guest")
    supplier = "supplier"  # –°–Ω–∞–±–∂–µ–Ω–µ—Ü ‚Äî –º–∞—Ç–µ—Ä–∏–∞–ª—ã, –ª–æ–≥–∏—Å—Ç–∏–∫–∞
    accountant = "accountant"  # –§–∏–Ω–∞–Ω—Å–∏—Å—Ç ‚Äî –¥–µ–Ω—å–≥–∏, —Å–º–µ—Ç—ã
    admin = "admin"  # –°–µ—Ä–≤–∏—Å–Ω—ã–π –∞–¥–º–∏–Ω


class TaskStatus(str, enum.Enum):
    todo = "todo"
    new = "new"
    in_progress = "in_progress"
    ready = "ready"


class SubscriptionStatus(str, enum.Enum):
    active = "active"
    trial = "trial"
    paused = "paused"
    canceled = "canceled"
    expired = "expired"


# --- File: utils/subscription_check.py ---

# utils/subscription_check.py
from typing import Callable, Any, Awaitable
from functools import wraps
from sqlalchemy.ext.asyncio import AsyncSession
from services.subscriptions import has_active_subscription_for_user, PermissionDenied


async def ensure_user_has_subscription(session: AsyncSession, user_id: int) -> bool:
    return await has_active_subscription_for_user(session, user_id)


def require_subscription(handler: Callable[..., Awaitable[Any]]):
    """
    –î–µ–∫–æ—Ä–∞—Ç–æ—Ä: —Ç—Ä–µ–±—É–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    handler –¥–æ–ª–∂–µ–Ω –ø—Ä–∏–Ω–∏–º–∞—Ç—å (session, user_id, ...)
    """

    @wraps(handler)
    async def wrapper(*args, **kwargs):
        session: AsyncSession | None = kwargs.get("session") or (
            args[0] if args else None
        )
        user_id: int | None = kwargs.get("user_id") or (
            args[1] if len(args) > 1 else None
        )

        if session is None or user_id is None:
            raise PermissionDenied("Session or user_id not passed to decorator")

        if not await ensure_user_has_subscription(session, user_id):
            raise PermissionDenied("User has no active subscription")

        return await handler(*args, **kwargs)

    return wrapper


# --- File: scripts/check_models_vs_db.py ---

#!/usr/bin/env python
"""
check_models_vs_db.py ‚Äî —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —á–µ–∫–µ—Ä –º–æ–¥–µ–ª–µ–π vs –ë–î.

–§–∏—á–∏:
  ‚úÖ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü, –∫–æ–ª–æ–Ω–æ–∫, —Ç–∏–ø–æ–≤
  ‚úÖ –ø—Ä–æ–≤–µ—Ä–∫–∞ PK/FK, unique, –∏–Ω–¥–µ–∫—Å–æ–≤
  ‚úÖ strict-—Ä–µ–∂–∏–º (--strict)
  ‚úÖ –≤—ã–≤–æ–¥ diff (alembic autogenerate) –ø—Ä—è–º–æ –≤ –∫–æ–Ω—Å–æ–ª—å
  ‚úÖ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –¥–ª—è TIMESTAMP vs DATETIME
  ‚úÖ json-–≤—ã–≤–æ–¥ (--json)
  ‚úÖ –ø—Ä–æ—Ñ–∏–ª–∏ –æ–∫—Ä—É–∂–µ–Ω–∏–π (--env dev/test/prod)
  ‚úÖ auto-fix —Ä–µ–∂–∏–º (--fix) ‚Äî –ø–µ—á–∞—Ç–∞–µ—Ç –≥–æ—Ç–æ–≤—ã–π alembic revision --autogenerate
  ‚úÖ apply —Ä–µ–∂–∏–º (--apply) ‚Äî autogenerate + upgrade head
  ‚úÖ pre-commit friendly (exit code 1 –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö)
"""

import sys
import os
import argparse
import json
from sqlalchemy import create_engine, inspect
from sqlalchemy.engine.url import make_url
from alembic.config import Config
from alembic.autogenerate import compare_metadata
from alembic.runtime.environment import EnvironmentContext
from alembic.script import ScriptDirectory
from subprocess import run

from models.base import Base
from config import DATABASE_URL

IGNORED_TABLES = {"alembic_version"}


def get_engine(database_url: str):
    url = make_url(database_url)
    if url.drivername.endswith("+asyncpg"):
        url = url.set(drivername="postgresql+psycopg2")
    return create_engine(url)


def compare_db(engine, metadata, strict=False):
    inspector = inspect(engine)

    db_tables = set(inspector.get_table_names())
    if not strict:
        db_tables -= IGNORED_TABLES
    model_tables = set(metadata.tables.keys())

    issues = []

    # missing / extra tables
    for t in model_tables - db_tables:
        issues.append(f"‚ùå Missing table in DB: {t}")
    for t in db_tables - model_tables:
        issues.append(f"‚ùå Extra table in DB: {t}")

    # columns
    for table in model_tables & db_tables:
        model_cols = metadata.tables[table].columns
        db_cols = {col["name"]: col for col in inspector.get_columns(table)}

        for col in model_cols:
            if col.name not in db_cols:
                issues.append(f"‚ùå Table {table}: missing column {col.name}")
                continue

            db_type = str(db_cols[col.name]["type"]).upper()
            model_type = str(col.type).upper()

            if db_type != model_type:
                # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ä–∞–∑–ª–∏—á–∏—è –º–µ–∂–¥—É TIMESTAMP –∏ DATETIME
                if {"TIMESTAMP", "DATETIME"} <= {db_type, model_type}:
                    continue  # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
                else:
                    issues.append(
                        f"‚ùå Table {table}, column {col.name}: type mismatch "
                        f"(DB: {db_type}, Model: {model_type})"
                    )

        for db_col in db_cols.keys() - {c.name for c in model_cols}:
            issues.append(f"‚ùå Table {table}: extra column {db_col}")

        # primary keys
        db_pks = set(inspector.get_pk_constraint(table).get("constrained_columns", []))
        model_pks = {c.name for c in model_cols if c.primary_key}
        if db_pks != model_pks:
            issues.append(
                f"‚ùå Table {table}: PK mismatch (DB: {db_pks}, Model: {model_pks})"
            )

        # foreign keys
        db_fks = {}
        for fk in inspector.get_foreign_keys(table):
            if fk.get("constrained_columns") and fk.get("referred_table"):
                db_fks[fk["constrained_columns"][0]] = fk["referred_table"]

        model_fks = {}
        for col in model_cols:
            for fk in col.foreign_keys:
                model_fks[col.name] = fk.column.table.name

        if db_fks != model_fks:
            issues.append(
                f"‚ùå Table {table}: FK mismatch (DB: {db_fks}, Model: {model_fks})"
            )

    return issues


def alembic_diff(metadata, database_url):
    url = make_url(database_url)
    if url.drivername.endswith("+asyncpg"):
        url = url.set(drivername="postgresql+psycopg2")

    engine = create_engine(url)
    alembic_cfg = Config("alembic.ini")
    script = ScriptDirectory.from_config(alembic_cfg)

    with engine.connect() as connection:
        env_ctx = EnvironmentContext(alembic_cfg, script)
        env_ctx.configure(connection=connection, target_metadata=metadata)

        diffs = []

        def _run(rev, context):
            nonlocal diffs
            diffs = compare_metadata(context, metadata)
            return []

        with env_ctx:
            env_ctx.run_migrations()
        return diffs


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--strict", action="store_true", help="strict mode (no ignored tables)"
    )
    parser.add_argument("--json", action="store_true", help="output in JSON")
    parser.add_argument(
        "--env", choices=["dev", "test", "prod"], default=None, help="select env"
    )
    parser.add_argument("--fix", action="store_true", help="show alembic autogenerate")
    parser.add_argument(
        "--apply", action="store_true", help="autogenerate + apply upgrade"
    )
    args = parser.parse_args()

    database_url = DATABASE_URL
    if args.env:
        env_key = f"DATABASE_URL_{args.env.upper()}"
        database_url = os.getenv(env_key, database_url)

    engine = get_engine(database_url)
    metadata = Base.metadata

    issues = compare_db(engine, metadata, strict=args.strict)

    if args.fix or args.apply:
        print("üîß Alembic autogenerate diff:")
        run(["alembic", "revision", "--autogenerate", "-m", "auto_check"], check=False)
        if args.apply:
            run(["alembic", "upgrade", "head"], check=True)

    if args.json:
        print(json.dumps({"issues": issues}, indent=2, ensure_ascii=False))
    else:
        for issue in issues:
            print(issue)

    if issues:
        sys.exit(1)
    else:
        print("‚úÖ –ú–æ–¥–µ–ª–∏ –∏ –ë–î —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É—é—Ç—Å—è")


if __name__ == "__main__":
    main()


# --- File: scripts/seed.py ---

# scripts/seed.py
# -*- coding: utf-8 -*-
"""
–ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω—ã–π –ø–æ—Å–µ–≤: —Å–æ–∑–¥–∞–µ—Ç —Ç–∞—Ä–∏—Ñ–Ω—ã–µ –ø–ª–∞–Ω—ã (free/basic/pro) –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ (id=1).
–ù–∞–¥–µ–∂–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã: –ø—ã—Ç–∞–µ—Ç—Å—è –Ω–∞–π—Ç–∏ —Ñ–∞–±—Ä–∏–∫—É –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Å–µ—Å—Å–∏–∏ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–æ–¥—É–ª—è—Ö.
"""
import sys
import os
import asyncio
import traceback
from typing import Tuple
from utils.enums import UserRole

from sqlalchemy import select

# --- —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –∫–æ—Ä–Ω–µ–≤–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –ø—Ä–æ–µ–∫—Ç–∞ –≤ sys.path ---
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if BASE_DIR not in sys.path:
    sys.path.insert(0, BASE_DIR)


# --- –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –ø–æ–∏—Å–∫ —Ñ–∞–±—Ä–∏–∫–∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Å–µ—Å—Å–∏–∏ ---
def find_session_factory() -> Tuple[callable, str]:
    candidates = [
        ("app.db.session", "async_session_maker"),
        ("app.db.session", "async_session"),
        ("db.session", "async_session_maker"),
        ("db.session", "async_session"),
        ("database", "async_session_maker"),
        ("database", "async_session"),
        ("app.database", "async_session_maker"),
    ]
    for mod_name, attr in candidates:
        try:
            mod = __import__(mod_name, fromlist=[attr])
            if hasattr(mod, attr):
                return getattr(mod, attr), f"{mod_name}.{attr}"
        except Exception:
            continue
    raise RuntimeError(
        "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ñ–∞–±—Ä–∏–∫—É –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Å–µ—Å—Å–∏–∏. –ü–æ–∏—Å–∫–∏ –≤–µ–ª–∏—Å—å –≤: "
        + ", ".join(f"{m}.{a}" for m, a in candidates)
    )


# --- –∏–º–ø–æ—Ä—Ç –º–æ–¥–µ–ª–µ–π (–ø—ã—Ç–∞–µ—Ç—Å—è –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø—É—Ç–µ–π) ---
try:
    from models.plan import Plan
    from models.user import User
except Exception:
    try:
        from app.models.plan import Plan
        from app.models.user import User
    except Exception as e:
        raise RuntimeError("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –º–æ–¥–µ–ª–∏ Plan/User: " + str(e))

# --- –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ—Å–µ–≤–∞ ---
PLANS = [
    {
        "code": "free",
        "name": "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Ç–∞—Ä–∏—Ñ",
        "monthly_price": 0,
        "period_days": 14,
        "features": {"features": ["–±–∞–∑–æ–≤—ã–µ"]},
    },
    {
        "code": "basic",
        "name": "–ë–∞–∑–æ–≤—ã–π —Ç–∞—Ä–∏—Ñ",
        "monthly_price": 10,
        "period_days": 30,
        "features": {"features": ["–∑–∞–¥–∞—á–∏", "—Ñ–∞–π–ª—ã"]},
    },
    {
        "code": "pro",
        "name": "–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ç–∞—Ä–∏—Ñ",
        "monthly_price": 30,
        "period_days": 30,
        "features": {"features": ["–∑–∞–¥–∞—á–∏", "—Ñ–∞–π–ª—ã", "–∞–Ω–∞–ª–∏—Ç–∏–∫–∞"]},
    },
]

ADMIN = {"id": 1, "tg_id": 0, "role": UserRole.admin}


# --- –æ—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–æ—Ü–µ–¥—É—Ä–∞ –ø–æ—Å–µ–≤–∞ ---
async def seed():
    session_factory, found = find_session_factory()
    print("–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ñ–∞–±—Ä–∏–∫–∞ —Å–µ—Å—Å–∏–π:", found)
    try:
        async with session_factory() as session:
            # –¢–∞—Ä–∏—Ñ–Ω—ã–µ –ø–ª–∞–Ω—ã
            added = 0
            for p in PLANS:
                stmt = select(Plan).where(Plan.code == p["code"])
                res = await session.execute(stmt)
                exists = res.scalar_one_or_none()
                if exists:
                    print(f"‚ö™ –ü–ª–∞–Ω —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: {p['code']}")
                else:
                    plan_payload = {
                        "code": p["code"],
                        "name": p["name"],
                        "monthly_price": p["monthly_price"],
                        "period_days": p["period_days"],
                        "features": p.get("features", None),
                    }
                    session.add(Plan(**plan_payload))
                    print(f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω –ø–ª–∞–Ω: {p['code']}")
                    added += 1

            # –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –ø–æ id
            admin_obj = await session.get(User, ADMIN["id"])
            if admin_obj:
                print("‚ö™ –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (id=1)")
            else:
                # create minimal required fields; model may require other fields ‚Äî adjust if needed
                admin_payload = {
                    "id": ADMIN["id"],
                    "tg_id": ADMIN["tg_id"],
                    "role": ADMIN["role"],
                }
                session.add(User(**admin_payload))
                print("‚úÖ –î–æ–±–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä (id=1)")

            await session.commit()
            print(f"\n–ü–æ—Å–µ–≤ –∑–∞–∫–æ–Ω—á–µ–Ω. –î–æ–±–∞–≤–ª–µ–Ω—ã –ø–ª–∞–Ω—ã: {added}")
    except Exception as e:
        print("ERROR –≤–æ –≤—Ä–µ–º—è –ø–æ—Å–µ–≤–∞():", e)
        traceback.print_exc()
        raise


if __name__ == "__main__":
    asyncio.run(seed())


# --- File: scripts/check_seed.py ---

# scripts/check_seed.py
# -*- coding: utf-8 -*-
"""
Check that seed objects exist and print summary.
"""
import sys
import os
import asyncio
import traceback

from sqlalchemy import select

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if BASE_DIR not in sys.path:
    sys.path.insert(0, BASE_DIR)


def find_session_factory():
    candidates = [
        ("app.db.session", "async_session_maker"),
        ("app.db.session", "async_session"),
        ("db.session", "async_session_maker"),
        ("db.session", "async_session"),
        ("database", "async_session_maker"),
        ("database", "async_session"),
    ]
    for mod_name, attr in candidates:
        try:
            mod = __import__(mod_name, fromlist=[attr])
            if hasattr(mod, attr):
                return getattr(mod, attr), f"{mod_name}.{attr}"
        except Exception:
            continue
    raise RuntimeError(
        "Cannot find async session factory. Tried: "
        + ", ".join(f"{m}.{a}" for m, a in candidates)
    )


try:
    from models.plan import Plan
    from models.user import User
except Exception:
    try:
        from app.models.plan import Plan
        from app.models.user import User
    except Exception as e:
        raise RuntimeError("Cannot import models: " + str(e))


async def check():
    session_factory, found = find_session_factory()
    print("Using session factory:", found)
    try:
        async with session_factory() as session:
            # plans
            res = await session.execute(select(Plan))
            plans = res.scalars().all()
            print("\nüìä Plans in DB:")
            if not plans:
                print("  (no plans)")
            for p in plans:
                # safe printing ‚Äî some attributes may be None
                print(
                    f" - {getattr(p, 'code', '?')} ({getattr(p, 'name', '?')}), "
                    f"price={getattr(p, 'monthly_price', '?')}, "
                    f"period={getattr(p, 'period_days', '?')}d"
                )

            # admin by id
            admin = await session.get(User, 1)
            if admin:
                print(
                    f"\nüëë Admin found: id={admin.id}, tg_id={admin.tg_id}, role={admin.role}"
                )
            else:
                print("\n‚ùå Admin not found (id=1).")
    except Exception as e:
        print("ERROR during check():", e)
        traceback.print_exc()
        raise


if __name__ == "__main__":
    asyncio.run(check())


# --- File: scripts/test_s3.py ---

import uuid
from storage.s3 import get_s3_client, ensure_bucket_exists, S3_BUCKET_NAME


def main():
    print(f"=== –ù–∞—á–∏–Ω–∞–µ–º —Ç–µ—Å—Ç S3. –ü—Ä–æ–≤–µ—Ä—è–µ–º bucket: {S3_BUCKET_NAME} ===")

    s3 = get_s3_client()
    if not ensure_bucket_exists(S3_BUCKET_NAME):
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∏–ª–∏ –Ω–∞–π—Ç–∏ bucket")
        return

    test_key = f"test/{uuid.uuid4()}.txt"
    test_content = b"Hello from test script!"

    # 1. –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª
    try:
        s3.put_object(Bucket=S3_BUCKET_NAME, Key=test_key, Body=test_content)
        print(f"‚úÖ –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω: {test_key}")
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}")
        return

    # 2. –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª –æ–±—Ä–∞—Ç–Ω–æ
    try:
        response = s3.get_object(Bucket=S3_BUCKET_NAME, Key=test_key)
        downloaded = response["Body"].read()
        if downloaded == test_content:
            print("‚úÖ –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω –∏ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –æ—Ä–∏–≥–∏–Ω–∞–ª–æ–º")
        else:
            print("‚ùå –§–∞–π–ª —Å–∫–∞—á–∞–Ω, –Ω–æ –¥–∞–Ω–Ω—ã–µ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç")
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è: {e}")


if __name__ == "__main__":
    main()


# --- File: scripts/clear_s3.py ---

from storage.s3 import get_s3_client, S3_BUCKET_NAME


def clear_bucket(bucket_name: str = S3_BUCKET_NAME, keep_uploads: bool = False):
    s3 = get_s3_client()
    print(f"üßπ –ß–∏—Å—Ç–∏–º bucket: {bucket_name} (keep_uploads={keep_uploads})")

    try:
        while True:
            objects = s3.list_objects_v2(Bucket=bucket_name)
            if "Contents" not in objects:
                print("‚úÖ Bucket —É–∂–µ –ø—É—Å—Ç")
                break

            if keep_uploads:
                keys = [
                    {"Key": obj["Key"]}
                    for obj in objects["Contents"]
                    if not obj["Key"].startswith("uploads/")
                ]
            else:
                keys = [{"Key": obj["Key"]} for obj in objects["Contents"]]

            if not keys:
                print("‚úÖ –£–¥–∞–ª—è—Ç—å –Ω–µ—á–µ–≥–æ (uploads/ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã)")
                break

            s3.delete_objects(Bucket=bucket_name, Delete={"Objects": keys})
            print(f"‚úÖ –£–¥–∞–ª–µ–Ω–æ {len(keys)} –æ–±—ä–µ–∫—Ç–æ–≤")

            if not objects.get("IsTruncated"):
                break

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ: {e}")


def main():
    import sys

    keep_uploads = "--keep-uploads" in sys.argv
    clear_bucket(keep_uploads=keep_uploads)


if __name__ == "__main__":
    main()


# --- File: scripts/setup_s3_lifecycle.py ---

# scripts/setup_s3_lifecycle.py
import os
from storage.s3 import get_s3_client


def create_lifecycle(bucket_name: str, compress_days: int = 30, delete_days: int = 90):
    s3 = get_s3_client()

    # –î–ª—è AWS S3: lifecycle configuration
    lifecycle = {
        "Rules": [
            {
                "ID": "compress-after-30",
                "Prefix": "",
                "Status": "Enabled",
                "Filter": {"Prefix": "project/"},
                "Transitions": [
                    # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å –≤ Glacier (—Ç.–æ. "–∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞—Ç—å")
                    {"Days": compress_days, "StorageClass": "STANDARD_IA"}
                ],
                "NoncurrentVersionExpiration": {"NoncurrentDays": delete_days},
            },
            {
                "ID": "delete-after-90",
                "Prefix": "",
                "Status": "Enabled",
                "Filter": {"Prefix": ""},
                "Expiration": {"Days": delete_days},
            },
        ]
    }

    # MinIO –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç PutBucketLifecycleConfiguration
    s3.put_bucket_lifecycle_configuration(
        Bucket=bucket_name, LifecycleConfiguration=lifecycle
    )
    print("Lifecycle applied to bucket:", bucket_name)


if __name__ == "__main__":
    bucket = os.getenv("S3_BUCKET_NAME")
    create_lifecycle(bucket)


# --- File: scripts/compress_and_archive.py ---

# scripts/compress_and_archive.py
import os
import logging
from datetime import datetime, timedelta
from sqlalchemy import select
from storage.s3 import get_object_bytes, upload_bytes, zip_bytes, delete_object
from database import async_session_maker, init_db
from models import File  # –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º –º–æ–¥–µ–ª—å File

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("compress")


async def run():
    await init_db()
    cutoff = datetime.utcnow() - timedelta(
        days=int(os.getenv("FILES_COMPRESS_DAYS", 30))
    )
    async with async_session_maker() as session:  # –µ—Å–ª–∏ —É —Ç–µ–±—è async_session_maker –æ–ø—Ä–µ–¥–µ–ª—ë–Ω
        q = await session.execute(
            select(File).where(
                File.created_at <= cutoff,
                File.s3_key.isnot(None),
                File.archived_at is None,
            )
        )
        files = q.scalars().all()
        for f in files:
            try:
                data = get_object_bytes(f.s3_key)
                if not data:
                    logger.warning("No data for %s", f.s3_key)
                    continue
                # –ø—Ä–æ—Å—Ç–∞—è –∞—Ä—Ö–∏–≤–∞—Ü–∏—è: —É–ø–∞–∫—É–µ–º –≤ zip –ø–æ–¥ —Ç–µ–º –∂–µ –∏–º–µ–Ω–µ–º
                zip_data = zip_bytes({f.filename or "file": data})
                new_key = f"{f.s3_key}.zip"
                upload_bytes(
                    zip_data,
                    new_key,
                    content_type="application/zip",
                    storage_class="STANDARD_IA",
                )
                # —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –æ–±—ä–µ–∫—Ç
                delete_object(f.s3_key)
                # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î –Ω–æ–≤—ã–π –∫–ª—é—á –∏ –ø–æ–º–µ—á–∞–µ–º archived_at
                f.s3_key = new_key
                f.storage_class = "STANDARD_IA"
                f.archived_at = datetime.utcnow()
                session.add(f)
                await session.commit()
                logger.info("Archived file %s -> %s", f.id, new_key)
            except Exception as e:
                logger.exception("Failed to archive file %s: %s", f.id, e)


if __name__ == "__main__":
    import asyncio

    asyncio.run(run())


# --- File: scripts/migrate_file_ids_to_s3.py ---

# scripts/migrate_file_ids_to_s3.py
import os
import io
import logging
import asyncio
from aiogram import Bot
from database import init_db, async_session_maker
from storage.s3 import upload_bytes

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("migrate")

BOT_TOKEN = os.getenv("BOT_TOKEN")


async def run():
    await init_db()
    bot = Bot(BOT_TOKEN)
    async with async_session_maker() as session:
        q = await session.execute(
            "SELECT * FROM files WHERE file_id IS NOT NULL AND s3_key IS NULL"
        )
        rows = q.fetchall()
        for row in rows:
            try:
                file_id = row.file_id
                file_info = await bot.get_file(file_id)
                buf = io.BytesIO()
                await file_info.download(out=buf)
                buf.seek(0)
                key = f"project/{row.id}/{file_info.file_path.split('/')[-1]}"
                upload_bytes(buf.read(), key)
                # –æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å –≤ –ë–î
                await session.execute(
                    "UPDATE files SET s3_key = :k, storage_provider = :p WHERE id = :id",
                    {"k": key, "p": os.getenv("S3_PROVIDER", "minio"), "id": row.id},
                )
                await session.commit()
                logger.info("Migrated file %s -> %s", row.id, key)
            except Exception as e:
                logger.exception("Error migrating file %s: %s", row.id, e)
    await bot.session.close()


if __name__ == "__main__":
    asyncio.run(run())


# --- File: scripts/populate_test_data.py ---

# –°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª scripts/populate_test_data.py
from models import User, Company  # –¢–µ–ø–µ—Ä—å –∏–º–ø–æ—Ä—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä–µ
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import os

engine = create_engine(os.getenv("DATABASE_URL"))
Session = sessionmaker(bind=engine)
session = Session()


def populate_data():
    # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    test_user = User(username="test_user", email="test@example.com", role="user")

    # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—É—é –∫–æ–º–ø–∞–Ω–∏—é
    test_company = Company(name="Test Company", created_by=test_user)

    session.add(test_user)
    session.add(test_company)
    session.commit()


if __name__ == "__main__":
    populate_data()


# --- File: scripts/test_subscriptions.py ---

# scripts/test_subscriptions.py
# -*- coding: utf-8 -*-
"""
–¢–µ—Å—Ç—ã –¥–ª—è —Å–µ—Ä–≤–∏—Å–æ–≤ –ø–æ–¥–ø–∏—Å–æ–∫ –∏ middleware-–¥–µ–∫–æ—Ä–∞—Ç–æ—Ä–∞.
"""
import sys
import os
import asyncio

from sqlalchemy import select

from database import async_session_maker
from models.company import Company
from models.user import User
from services.subscriptions import (
    create_subscription,
    get_active_subscription,
    has_active_subscription_for_user,
)
from utils.subscription_check import require_subscription


BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if BASE_DIR not in sys.path:
    sys.path.insert(0, BASE_DIR)


async def main():
    async with async_session_maker() as session:
        # 1. ensure company exists
        stmt = select(Company).where(Company.id == 1)
        company = (await session.execute(stmt)).scalar_one_or_none()
        if not company:
            company = Company(id=1, name="TestCo")
            session.add(company)
            print("‚úÖ Created test company id=1")

        # 2. ensure user exists
        user = await session.get(User, 1)
        if not user:
            user = User(id=1, tg_id=12345, role="admin")
            session.add(user)
            print("‚úÖ Created test user id=1")

        await session.commit()

        # 3. create subscription
        try:
            sub = await create_subscription(
                session, company_id=1, plan_code="free", actor_id=1, commit=True
            )
            print(
                f"‚úÖ Created subscription id={sub.id}, status={sub.status}, "
                f"start={sub.starts_at}, expire={sub.expires_at}"
            )
        except Exception as e:
            print("‚ö†Ô∏è Create failed:", e)

        # 4. get active subscription
        active = await get_active_subscription(session, 1)
        print("üìä Active subscription:", active.id if active else None)

        # 5. test has_active_subscription_for_user
        ok = await has_active_subscription_for_user(session, user_id=1)
        print("üë§ User 1 has active subscription?", ok)

        # 6. test require_subscription decorator
        @require_subscription
        async def my_handler(session, user_id):
            return f"–ü—Ä–∏–≤–µ—Ç, –ø–æ–¥–ø–∏—Å–∫–∞ –µ—Å—Ç—å —É user_id={user_id}!"

        try:
            msg = await my_handler(session=session, user_id=1)
            print("üí¨ Handler result:", msg)
        except Exception as e:
            print("‚ùå Handler denied:", e)


if __name__ == "__main__":
    asyncio.run(main())


# --- File: migrations/env.py ---

from logging.config import fileConfig
from sqlalchemy import create_engine, pool  # –£–±—Ä–∞–ª–∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã
from alembic import context
import os

from models.base import Base

# ==============================================================================
# –£–¥–∞–ª–µ–Ω—ã –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –∏–º–ø–æ—Ä—Ç—ã
# from sqlalchemy.ext.asyncio import create_async_engine
# import asyncio
# ==============================================================================

config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata


# ==============================================================================
# –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è URL
def get_url():
    # 1Ô∏è‚É£ —Å–Ω–∞—á–∞–ª–∞ —á–∏—Ç–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä, –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π —á–µ—Ä–µ–∑ CLI: alembic -x db_url=...
    x_args = context.get_x_argument(as_dictionary=True)
    if "db_url" in x_args:
        return x_args["db_url"]

    # 2Ô∏è‚É£ –∑–∞—Ç–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã
    return (
        os.getenv("SYNC_TEST_DATABASE_URL")
        or os.getenv("SYNC_DATABASE_URL")
        or config.get_main_option("sqlalchemy.url")
        or os.getenv("DATABASE_URL")
    )


test_url = os.getenv("SYNC_TEST_DATABASE_URL") or os.getenv("DATABASE_URL")
if test_url:
    config.set_main_option("sqlalchemy.url", test_url)


# ==============================================================================
# –£–¥–∞–ª–µ–Ω–Ω—ã–π —Å—Ç–∞—Ä—ã–π –∫–æ–¥ —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
# logger = logging.getLogger(__name__)
# logger.setLevel(logging.DEBUG if os.getenv("DEBUG") else logging.INFO)

# def get_url():
#     cfg_url = config.get_main_option("sqlalchemy.url")
#     test_url = os.getenv("TEST_DATABASE_URL")
#     db_url = os.getenv("DATABASE_URL")

#     logger.info(
#         f"alembic.env cfg.sqlalchemy.url={cfg_url!r} TEST_DATABASE_URL={test_url!r} DATABASE_URL={db_url!r}"
#     )

#     return cfg_url or test_url or db_url
# ==============================================================================


def run_migrations_offline():
    url = get_url()
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        compare_type=True,
        compare_server_default=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()


# ==============================================================================
# –ù–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –æ–Ω–ª–∞–π–Ω-–º–∏–≥—Ä–∞—Ü–∏–π —Å —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º
def run_migrations_online():
    connectable = create_engine(get_url(), poolclass=pool.NullPool)
    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            compare_type=True,
            compare_server_default=True,
        )
        with context.begin_transaction():
            context.run_migrations()


# ==============================================================================
# –£–¥–∞–ª–µ–Ω–Ω—ã–π —Å—Ç–∞—Ä—ã–π –∫–æ–¥ —Å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–º–∏ –º–∏–≥—Ä–∞—Ü–∏—è–º–∏
# async def run_migrations_online():
#     """
#     –ó–∞–ø—É—Å–∫ –æ–Ω–ª–∞–π–Ω-–º–∏–≥—Ä–∞—Ü–∏–π (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –º–∏–≥—Ä–∞—Ü–∏–π).
#     """
#     url = get_url()
#     if not url:
#         raise RuntimeError("sqlalchemy.url is not set in alembic.ini or via env")

#     logger.info(f"Online migrations with url={url}")

#     connectable = create_async_engine(url, future=True, echo=False)

#     try:
#         async with connectable.connect() as connection:
#             await connection.run_sync(do_run_migrations)
#     except Exception as e:
#         logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –º–∏–≥—Ä–∞—Ü–∏–∏: {e}")
#         raise
# ==============================================================================

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


# --- File: migrations/versions/711c8b8f6276_baseline_schema.py ---

"""baseline schema

Revision ID: 711c8b8f6276
Revises:
Create Date: 2025-09-25 08:39:18.637249

"""

from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = "711c8b8f6276"
down_revision: Union[str, Sequence[str], None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "audit_logs",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("actor_user_id", sa.BigInteger(), nullable=True),
        sa.Column("actor_tg_id", sa.BigInteger(), nullable=True),
        sa.Column("action", sa.String(length=255), nullable=False),
        sa.Column("entity_type", sa.String(length=100), nullable=True),
        sa.Column("entity_id", sa.BigInteger(), nullable=True),
        sa.Column("payload", sa.JSON(), nullable=True),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "companies",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("created_by", sa.BigInteger(), nullable=True),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "plans",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("code", sa.String(length=50), nullable=False),
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("monthly_price", sa.Integer(), nullable=False),
        sa.Column("period_days", sa.Integer(), nullable=False),
        sa.Column("features", postgresql.JSONB(astext_type=sa.Text()), nullable=True),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("code"),
    )
    op.create_table(
        "invoices",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("company_id", sa.BigInteger(), nullable=False),
        sa.Column("plan_id", sa.BigInteger(), nullable=False),
        sa.Column("amount", sa.Numeric(precision=10, scale=2), nullable=False),
        sa.Column(
            "currency", sa.String(length=3), server_default="USD", nullable=False
        ),
        sa.Column(
            "status",
            sa.Enum("pending", "paid", "failed", name="invoice_status"),
            server_default="pending",
            nullable=False,
        ),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.ForeignKeyConstraint(["company_id"], ["companies.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["plan_id"], ["plans.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(
        op.f("ix_invoices_company_id"), "invoices", ["company_id"], unique=False
    )
    op.create_index(op.f("ix_invoices_plan_id"), "invoices", ["plan_id"], unique=False)
    op.create_table(
        "projects",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("name", sa.String(), nullable=False),
        sa.Column("company_id", sa.BigInteger(), nullable=False),
        sa.Column("deleted_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.ForeignKeyConstraint(["company_id"], ["companies.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(
        op.f("ix_projects_company_id"), "projects", ["company_id"], unique=False
    )
    op.create_table(
        "subscriptions",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("company_id", sa.BigInteger(), nullable=False),
        sa.Column("plan_id", sa.BigInteger(), nullable=False),
        sa.Column(
            "status",
            postgresql.ENUM(
                "active",
                "trial",
                "paused",
                "canceled",
                "expired",
                name="subscription_status",
            ),
            server_default="trial",
            nullable=False,
        ),
        sa.Column("starts_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column("created_by", sa.BigInteger(), nullable=True),
        sa.Column("updated_by", sa.BigInteger(), nullable=True),
        sa.ForeignKeyConstraint(["company_id"], ["companies.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["plan_id"], ["plans.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(
        op.f("ix_subscriptions_company_id"),
        "subscriptions",
        ["company_id"],
        unique=False,
    )
    op.create_table(
        "trials",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("company_id", sa.BigInteger(), nullable=False),
        sa.Column(
            "starts_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("is_active", sa.Boolean(), server_default="true", nullable=False),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column("created_by", sa.BigInteger(), nullable=True),
        sa.Column("updated_by", sa.BigInteger(), nullable=True),
        sa.ForeignKeyConstraint(["company_id"], ["companies.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "users",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("tg_id", sa.BigInteger(), nullable=False),
        sa.Column(
            "role",
            sa.Enum(
                "manager",
                "foreman",
                "worker",
                "client",
                "supplier",
                "accountant",
                "admin",
                name="user_role",
            ),
            nullable=False,
        ),
        sa.Column("company_id", sa.BigInteger(), nullable=True),
        sa.Column("phone_number", sa.BigInteger(), nullable=True),
        sa.Column(
            "is_active", sa.Boolean(), server_default=sa.text("true"), nullable=False
        ),
        sa.Column("deleted_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.ForeignKeyConstraint(["company_id"], ["companies.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("tg_id"),
    )
    op.create_table(
        "payments",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("invoice_id", sa.BigInteger(), nullable=False),
        sa.Column("amount", sa.Numeric(precision=10, scale=2), nullable=False),
        sa.Column(
            "currency", sa.String(length=3), server_default="USD", nullable=False
        ),
        sa.Column(
            "status",
            sa.Enum("pending", "paid", "failed", name="payment_status"),
            server_default="pending",
            nullable=False,
        ),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.ForeignKeyConstraint(["invoice_id"], ["invoices.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(
        op.f("ix_payments_invoice_id"), "payments", ["invoice_id"], unique=False
    )
    op.create_table(
        "sessions",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.BigInteger(), nullable=False),
        sa.Column("refresh_token", sa.String(length=255), nullable=False),
        sa.Column("device_info", sa.String(length=255), nullable=True),
        sa.Column("ip_address", sa.String(length=50), nullable=True),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("refresh_token"),
    )
    op.create_table(
        "tasks",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("title", sa.String(), nullable=False),
        sa.Column("description", sa.Text(), nullable=True),
        sa.Column(
            "status",
            sa.Enum("todo", "new", "in_progress", "ready", name="taskstatus"),
            server_default="todo",
            nullable=False,
        ),
        sa.Column("project_id", sa.BigInteger(), nullable=True),
        sa.Column("company_id", sa.BigInteger(), nullable=False),
        sa.Column("user_id", sa.BigInteger(), nullable=True),
        sa.Column("deleted_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.ForeignKeyConstraint(["company_id"], ["companies.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["project_id"], ["projects.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="SET NULL"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(op.f("ix_tasks_company_id"), "tasks", ["company_id"], unique=False)
    op.create_index(op.f("ix_tasks_project_id"), "tasks", ["project_id"], unique=False)
    op.create_index(op.f("ix_tasks_user_id"), "tasks", ["user_id"], unique=False)
    op.create_table(
        "files",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("task_id", sa.BigInteger(), nullable=False),
        sa.Column("company_id", sa.BigInteger(), nullable=False),
        sa.Column("uploader_id", sa.BigInteger(), nullable=True),
        sa.Column("s3_key", sa.String(), nullable=False),
        sa.Column("original_name", sa.String(), nullable=False),
        sa.Column("size", sa.BigInteger(), nullable=False),
        sa.Column("mime_type", sa.String(), nullable=False),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("now()"),
            nullable=False,
        ),
        sa.ForeignKeyConstraint(["company_id"], ["companies.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["task_id"], ["tasks.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["uploader_id"], ["users.id"], ondelete="SET NULL"),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("s3_key"),
    )
    op.create_index(op.f("ix_files_company_id"), "files", ["company_id"], unique=False)
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f("ix_files_company_id"), table_name="files")
    op.drop_table("files")
    op.drop_index(op.f("ix_tasks_user_id"), table_name="tasks")
    op.drop_index(op.f("ix_tasks_project_id"), table_name="tasks")
    op.drop_index(op.f("ix_tasks_company_id"), table_name="tasks")
    op.drop_table("tasks")
    op.drop_table("sessions")
    op.drop_index(op.f("ix_payments_invoice_id"), table_name="payments")
    op.drop_table("payments")
    op.drop_table("users")
    op.drop_table("trials")
    op.drop_index(op.f("ix_subscriptions_company_id"), table_name="subscriptions")
    op.drop_table("subscriptions")
    op.drop_index(op.f("ix_projects_company_id"), table_name="projects")
    op.drop_table("projects")
    op.drop_index(op.f("ix_invoices_plan_id"), table_name="invoices")
    op.drop_index(op.f("ix_invoices_company_id"), table_name="invoices")
    op.drop_table("invoices")
    op.drop_table("plans")
    op.drop_table("companies")
    op.drop_table("audit_logs")
    # ### end Alembic commands ###


# --- File: storage/s3.py ---

import os
import boto3
from botocore.client import Config
from botocore.exceptions import ClientError
from uuid import uuid4

S3_ACCESS_KEY_ID = os.getenv("S3_ACCESS_KEY_ID")
S3_SECRET_ACCESS_KEY = os.getenv("S3_SECRET_ACCESS_KEY")
S3_BUCKET_NAME = os.getenv("S3_BUCKET_NAME")
S3_REGION = os.getenv("S3_REGION", "us-east-1")
S3_ENDPOINT_URL = os.getenv("S3_ENDPOINT_URL", "http://minio:9000")


def get_s3_client():
    return boto3.client(
        "s3",
        endpoint_url=S3_ENDPOINT_URL,
        aws_access_key_id=S3_ACCESS_KEY_ID,
        aws_secret_access_key=S3_SECRET_ACCESS_KEY,
        region_name=S3_REGION,
        config=Config(signature_version="s3v4"),
    )


def ensure_bucket_exists(bucket_name: str = S3_BUCKET_NAME):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ bucket —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –ï—Å–ª–∏ –Ω–µ—Ç ‚Äî —Å–æ–∑–¥–∞—ë—Ç.
    –†–∞–±–æ—Ç–∞–µ—Ç –∏ —Å MinIO, –∏ —Å AWS S3.
    """
    client = get_s3_client()
    try:
        client.head_bucket(Bucket=bucket_name)
        print(f"‚úÖ Bucket {bucket_name} —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
        return True
    except ClientError as e:
        code = e.response.get("Error", {}).get("Code", "")
        if code in ("404", "NoSuchBucket"):
            # —Å–æ–∑–¥–∞—ë–º bucket
            try:
                if S3_ENDPOINT_URL and "minio" in S3_ENDPOINT_URL:
                    # MinIO –Ω–µ –ª—é–±–∏—Ç LocationConstraint
                    client.create_bucket(Bucket=bucket_name)
                else:
                    if S3_REGION == "us-east-1":
                        client.create_bucket(Bucket=bucket_name)
                    else:
                        client.create_bucket(
                            Bucket=bucket_name,
                            CreateBucketConfiguration={"LocationConstraint": S3_REGION},
                        )
                print(f"‚úÖ Bucket {bucket_name} —Å–æ–∑–¥–∞–Ω")
                return True
            except Exception as ce:
                print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ bucket {bucket_name}: {ce}")
                return False
        elif code in ("403", "AccessDenied"):
            # –ú–æ–∂–µ—Ç –±—ã—Ç—å, bucket –µ—Å—Ç—å, –Ω–æ –¥–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω
            print(f"‚ö†Ô∏è Bucket {bucket_name} –µ—Å—Ç—å, –Ω–æ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ (403)")
            return True
        else:
            print(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ bucket {bucket_name}: {e}")
            return False


def generate_presigned_put_url(key: str = None, expires_in: int = 3600) -> str:
    """
    –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Å—Å—ã–ª–∫–∏ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ (PUT).
    """
    if key is None:
        key = f"uploads/{uuid4()}.bin"

    client = get_s3_client()
    return client.generate_presigned_url(
        "put_object",
        Params={"Bucket": S3_BUCKET_NAME, "Key": key},
        ExpiresIn=expires_in,
    )


def generate_presigned_get_url(key: str, expires_in: int = 3600) -> str:
    """
    –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Å—Å—ã–ª–∫–∏ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞ (GET).
    """
    client = get_s3_client()
    return client.generate_presigned_url(
        "get_object",
        Params={"Bucket": S3_BUCKET_NAME, "Key": key},
        ExpiresIn=expires_in,
    )


# --- File: storage/__init__.py ---



# --- File: tests/test_audit_log.py ---

import pytest
from sqlalchemy import text

from models import AuditLog
from services.audit import log_action


@pytest.mark.asyncio
async def test_audit_log_insert(session):
    # –æ—á–∏—Å—Ç–∫–∞ —Ç–∞–±–ª–∏—Ü—ã
    await session.execute(text("TRUNCATE TABLE audit_logs RESTART IDENTITY CASCADE"))
    await session.commit()

    # –ª–æ–≥–∏—Ä—É–µ–º –¥–µ–π—Å—Ç–≤–∏–µ
    await log_action(
        session=session,
        actor_user_id=1,
        actor_tg_id=111111111,
        action="test_action",
        entity_type="project",
        entity_id=123,
        payload={"info": "hello world"},
    )
    await session.commit()

    result = await session.execute(
        AuditLog.__table__.select().order_by(AuditLog.id.desc()).limit(1)
    )
    last = result.fetchone()
    assert last is not None, "‚ùå –ó–∞–ø–∏—Å—å –Ω–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª–∞—Å—å!"
    assert last.action == "test_action"


# --- File: tests/test_cascade_relations.py ---

import pytest
from sqlalchemy import select
from models import Company, Project, Task, File


@pytest.mark.asyncio
async def test_delete_project_cascades_tasks_and_files(db_session):
    """–£–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ –¥–æ–ª–∂–Ω–æ –∫–∞—Å–∫–∞–¥–Ω–æ —É–¥–∞–ª—è—Ç—å —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ –∏ —Ñ–∞–π–ª—ã."""

    # 1Ô∏è‚É£ –°–æ–∑–¥–∞—ë–º –∫–æ–º–ø–∞–Ω–∏—é
    company = Company(name="Test Company")
    db_session.add(company)
    db_session.flush()  # –±–µ–∑ await, –ø–æ—Ç–æ–º—É —á—Ç–æ sync session

    # 2Ô∏è‚É£ –°–æ–∑–¥–∞—ë–º –ø—Ä–æ–µ–∫—Ç, –∑–∞–¥–∞—á—É –∏ —Ñ–∞–π–ª
    project = Project(name="Demo project", company_id=company.id)
    task = Task(title="Test task", company_id=company.id, project=project)
    file = File(
        task=task,
        company_id=company.id,
        s3_key="demo/file.txt",
        original_name="file.txt",
        size=100,
        mime_type="text/plain",
    )

    db_session.add_all([project, task, file])
    db_session.commit()

    # 3Ô∏è‚É£ –£–¥–∞–ª—è–µ–º –ø—Ä–æ–µ–∫—Ç
    db_session.delete(project)
    db_session.commit()

    # 4Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—Å–∫–∞–¥
    assert not db_session.scalar(select(Task).where(Task.project_id == project.id))
    assert not db_session.scalar(select(File).where(File.task_id == task.id))


# --- File: tests/utils.py ---

import uuid

# –•—Ä–∞–Ω–∏–ª–∏—â–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö ID (—Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∑–∞–ø—É—Å–∫–∞ —Ç–µ—Å—Ç–æ–≤)
_issued_tg_ids: set[int] = set()


def unique_tg_id() -> int:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π tg_id –¥–ª—è —Ç–µ—Å—Ç–æ–≤ (–±–µ–∑ –ø–æ–≤—Ç–æ—Ä–æ–≤ –≤ —Ä–∞–º–∫–∞—Ö –æ–¥–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞)."""
    while True:
        tg_id = int(uuid.uuid4().int % 1_000_000_000)
        if tg_id not in _issued_tg_ids:
            _issued_tg_ids.add(tg_id)
            return tg_id


# --- File: tests/smoke/test_billing_flow.py ---

import pytest
from sqlalchemy import select
from models import Trial
from services.users import get_or_create_user
from services.companies import create_company
from services.subscriptions import has_active_subscription_for_user
from tests.utils import unique_tg_id


@pytest.mark.smoke
@pytest.mark.smoke_billing
@pytest.mark.asyncio
async def test_billing_flow(session):
    user, _ = await get_or_create_user(session, tg_id=unique_tg_id())  # üëà –∏—Å–ø–æ–ª—å–∑—É–µ–º
    await session.commit()

    company = await create_company(session, name="BillingCo", created_by=user.id)
    await session.commit()

    trial_q = await session.execute(select(Trial).where(Trial.company_id == company.id))
    trial = trial_q.scalar_one()
    assert trial.is_active is True

    has_sub = await has_active_subscription_for_user(session, user.id)
    assert has_sub is True


# --- File: tests/smoke/test_core_flow.py ---

import pytest
from services.users import get_or_create_user
from services.companies import create_company, join_company
from services.projects import create_project, get_projects_by_company_id
from services.tasks import create_task, get_my_tasks
from tests.utils import unique_tg_id


@pytest.mark.smoke
@pytest.mark.smoke_core
@pytest.mark.asyncio
async def test_core_flow(session):
    user, created = await get_or_create_user(session, tg_id=unique_tg_id())  # üëà
    await session.commit()
    assert created is True
    assert user.id

    company = await create_company(session, name="CoreCo", created_by=user.id)
    await session.commit()
    assert company.id

    user = await join_company(session, user, company)
    await session.commit()
    assert user.company_id == company.id

    project = await create_project(session, name="Core Project", company_id=company.id)
    assert project.id

    projects = await get_projects_by_company_id(session, company.id)
    assert any(p.id == project.id for p in projects)

    task = await create_task(
        session,
        title="Core Task",
        description="Check flow",
        project_id=project.id,
        company_id=company.id,
        user_id=user.id,
    )
    assert task.id

    my_tasks = await get_my_tasks(session, user.id)
    assert any(t.id == task.id for t in my_tasks)


# --- File: tests/smoke/test_files_flow.py ---

import pytest
import uuid
from services.users import get_or_create_user
from services.companies import create_company, join_company
from services.projects import create_project
from services.tasks import create_task
from services.files import create_file, get_file_by_id
from tests.utils import unique_tg_id


@pytest.mark.smoke
@pytest.mark.smoke_files
@pytest.mark.asyncio
async def test_files_flow(session):
    user, _ = await get_or_create_user(session, tg_id=unique_tg_id())  # üëà
    await session.commit()

    company = await create_company(session, name="FilesCo", created_by=user.id)
    await session.commit()

    user = await join_company(session, user, company)
    await session.commit()

    project = await create_project(session, "Files Project", company.id)
    task = await create_task(
        session, "Files Task", "check files", project.id, company.id, user.id
    )
    await session.commit()

    fake_file_id = str(uuid.uuid4())
    file = await create_file(
        session,
        task_id=task.id,
        company_id=company.id,
        uploader_id=user.id,
        original_name="test.txt",
        mime_type="text/plain",
        size=123,
        s3_key=f"fake/{fake_file_id}.txt",
    )
    await session.commit()

    f2 = await get_file_by_id(session, file.id)
    assert f2 is not None
    assert f2.original_name == "test.txt"


# --- File: metrics/prometheus.py ---

import time
from fastapi import Request, Response
from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST

# –°—á—ë—Ç—á–∏–∫–∏ –∑–∞–ø—Ä–æ—Å–æ–≤
REQUEST_COUNT = Counter("requests_total", "Total requests", ["method", "endpoint"])
REQUEST_LATENCY = Histogram(
    "requests_latency_seconds", "Request latency (s)", ["endpoint"]
)


# Middleware ‚Äî –¥–ª—è FastAPI –∏–ª–∏ aiohttp
async def metrics_middleware(request: Request, call_next):
    start = time.time()
    response = await call_next(request)
    duration = time.time() - start
    REQUEST_COUNT.labels(request.method, request.url.path).inc()
    REQUEST_LATENCY.labels(request.url.path).observe(duration)
    return response


# Endpoint /metrics
async def metrics_endpoint():
    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)


# --- File: __init__.py ---

# –û—Å—Ç–∞–≤—å—Ç–µ —ç—Ç–æ—Ç —Ñ–∞–π–ª –ø—É—Å—Ç—ã–º. –ù–∏–∫–∞–∫–∏—Ö –∏–º–ø–æ—Ä—Ç–æ–≤!


# --- File: database.py ---

import os
from sqlalchemy import event
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from models.base import Base

# –ß–∏—Ç–∞–µ–º –∞—Ç–æ–º–∞—Ä–Ω—ã–µ ENV (—Å –¥–µ—Ñ–æ–ª—Ç–∞–º–∏ –¥–ª—è –ª–æ–∫–∞–ª–∞)
POSTGRES_USER = os.getenv("POSTGRES_USER", "saasuser")
POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD", "saaspass")
POSTGRES_HOST = os.getenv("POSTGRES_HOST", "localhost")
POSTGRES_PORT = os.getenv("POSTGRES_PORT", "5432")
POSTGRES_DB = os.getenv("POSTGRES_DB", "saasdb")

# –°–±–æ—Ä–∫–∞ –ø–æ–ª–Ω–æ–≥–æ URL
DATABASE_URL = (
    os.getenv("DATABASE_URL")
    or os.getenv("TEST_DATABASE_URL")
    or f"postgresql+asyncpg://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_HOST}:{POSTGRES_PORT}/{POSTGRES_DB}"
)

# Async engine + sessionmaker
async_engine = create_async_engine(DATABASE_URL, echo=False, future=True)
async_session_maker = async_sessionmaker(
    bind=async_engine, class_=AsyncSession, expire_on_commit=False
)


async def init_db():
    """–°–æ–∑–¥–∞–Ω–∏–µ –≤—Å–µ—Ö —Ç–∞–±–ª–∏—Ü (–±–µ–∑ —Å–∏–¥–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–∞—Ä–∏—Ñ–æ–≤)."""
    async with async_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    return async_session_maker


# Audit –ø–æ–ª—è
def set_audit_fields(session, flush_context, instances):
    actor_id = session.info.get("actor_id")
    if not actor_id:
        return
    for obj in session.new:
        if hasattr(obj, "created_by") and not getattr(obj, "created_by", None):
            obj.created_by = actor_id
    for obj in session.dirty:
        if hasattr(obj, "updated_by"):
            obj.updated_by = actor_id


event.listen(async_session_maker().sync_session_class, "before_flush", set_audit_fields)


# --- File: conftest.py ---

# conftest.py
import os
import logging
import pytest
import pytest_asyncio

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine, text
from alembic.config import Config
from alembic import command
from models.base import Base
from dotenv import load_dotenv

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ----------------------
# üîπ Load environment for tests
# ----------------------
ENV_TEST_PATH = ".env.test"
if os.path.exists(ENV_TEST_PATH):
    load_dotenv(ENV_TEST_PATH, override=True)
    print(f"‚úÖ Loaded {ENV_TEST_PATH}")
else:
    load_dotenv(".env", override=False)
    print("‚ö†Ô∏è .env.test not found ‚Äî loaded default .env (not recommended for tests)")


# ----------------------
# üîπ Build URLs and enforce test safety
# ----------------------
def ensure_sync_url(url: str) -> str:
    if not url:
        return ""
    return url.replace("+asyncpg", "+psycopg2") if "+asyncpg" in url else url


# Try all possible sources for DB connection
ASYNC_TEST_DATABASE_URL = (
    os.getenv("ASYNC_TEST_DATABASE_URL")
    or os.getenv("DATABASE_URL")
    or "postgresql+asyncpg://{user}:{password}@{host}:{port}/{db}".format(
        user=os.getenv("POSTGRES_USER", "saasuser"),
        password=os.getenv("POSTGRES_PASSWORD", "saaspass"),
        host=os.getenv("POSTGRES_HOST", "localhost"),
        port=os.getenv("POSTGRES_PORT", "5432"),
        db=os.getenv("POSTGRES_DB", "saasdb_test"),
    )
)
SYNC_TEST_DATABASE_URL = os.getenv("SYNC_TEST_DATABASE_URL") or ensure_sync_url(
    ASYNC_TEST_DATABASE_URL
)

if not ASYNC_TEST_DATABASE_URL:
    raise RuntimeError(
        "‚ùå ASYNC_TEST_DATABASE_URL not set ‚Äî check .env.test or env_file"
    )

# Force DATABASE_URL to point to test DB
os.environ["DATABASE_URL"] = ASYNC_TEST_DATABASE_URL
os.environ["SYNC_TEST_DATABASE_URL"] = SYNC_TEST_DATABASE_URL

# Safety guard
if "test" not in (ASYNC_TEST_DATABASE_URL or ""):
    raise RuntimeError(
        f"‚ùå Refusing to run tests against non-test database!\nDATABASE_URL={ASYNC_TEST_DATABASE_URL}"
    )

logger.info(f"[pytest.conftest] ASYNC_TEST_DATABASE_URL={ASYNC_TEST_DATABASE_URL}")
logger.info(f"[pytest.conftest] SYNC_TEST_DATABASE_URL={SYNC_TEST_DATABASE_URL}")


# ----------------------
# üîπ Apply migrations (once per session)
# ----------------------
@pytest.fixture(scope="session", autouse=True)
def apply_migrations():
    """Run migrations once for smoke/flow tests."""
    if os.getenv("USE_MIGRATIONS", "true").lower() != "true":
        return

    logger.info("üöÄ Applying migrations...")
    sync_engine = create_engine(SYNC_TEST_DATABASE_URL)

    reset_db = os.getenv("RESET_DB", "true").lower() == "true"
    if reset_db:
        with sync_engine.begin() as conn:
            conn.execute(text("DROP SCHEMA IF EXISTS public CASCADE"))
            conn.execute(text("CREATE SCHEMA public"))

    alembic_cfg = Config("alembic.ini")
    alembic_cfg.set_main_option("sqlalchemy.url", SYNC_TEST_DATABASE_URL)
    alembic_cfg.set_main_option("script_location", "migrations")
    command.upgrade(alembic_cfg, "head")
    logger.info("‚úÖ Migrations applied")


# ----------------------
# üîπ Async test session
# ----------------------
@pytest_asyncio.fixture(scope="function")
async def engine(apply_migrations):
    async_engine = create_async_engine(ASYNC_TEST_DATABASE_URL, echo=False, future=True)
    yield async_engine
    await async_engine.dispose()


@pytest_asyncio.fixture(scope="function")
async def session(engine):
    async_session = sessionmaker(
        engine, expire_on_commit=False, class_=AsyncSession, future=True
    )
    async with async_session() as s:
        yield s


# ----------------------
# üîπ Sync session (for cascade/unit tests)
# ----------------------
@pytest.fixture(scope="function")
def db_session():
    sync_engine = create_engine(SYNC_TEST_DATABASE_URL)
    Session = sessionmaker(bind=sync_engine)
    session = Session()

    Base.metadata.drop_all(bind=sync_engine)
    Base.metadata.create_all(bind=sync_engine)

    try:
        yield session
    finally:
        session.rollback()
        session.close()
        sync_engine.dispose()


# --- File: check_connection.py ---

import socket
import sys

HOST = "aws-1-eu-central-1.pooler.supabase.com"
PORT = 5432

try:
    with socket.create_connection((HOST, PORT), timeout=10) as s:
        print(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ {HOST} –Ω–∞ –ø–æ—Ä—Ç—É {PORT}")
        sys.exit(0)
except TimeoutError:
    print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ {HOST} –Ω–∞ –ø–æ—Ä—Ç—É {PORT}. –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –≤—ã—à–ª–æ.")
    print("–≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–≤—è–∑–∞–Ω–æ —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π —Ñ–∞–π—Ä–≤–æ–ª–æ–º –∏–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞–º–∏ —Å —Å–µ—Ç—å—é.")
    sys.exit(1)
except Exception as e:
    print(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}")
    print("–í–æ–∑–º–æ–∂–Ω–æ, –∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞ –Ω–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è.")
    sys.exit(1)


# --- File: worker.py ---

import asyncio
import logging
import os

from aiogram import Bot
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

from database import init_db, async_session_maker
from services import notify_jobs

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
)
logger = logging.getLogger("worker")

BOT_TOKEN = os.getenv("BOT_TOKEN")


async def run_jobs():
    """–û–±–µ—Ä—Ç–æ—á–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∑–∞–¥–∞—á"""
    async with async_session_maker() as session:
        bot = Bot(BOT_TOKEN)
        await notify_jobs.run_all(session, bot)
        await bot.session.close()
    logger.info("‚úÖ –í—Å–µ –∑–∞–¥–∞—á–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã")


async def main():
    logger.info("üöÄ Worker started")
    await init_db()

    scheduler = AsyncIOScheduler(timezone="UTC")

    # –ó–∞–ø—É—Å–∫–∞–µ–º –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 09:00 UTC
    scheduler.add_job(run_jobs, CronTrigger(hour=9, minute=0))

    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫ —Å—Ä–∞–∑—É –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
    asyncio.create_task(run_jobs())

    scheduler.start()

    # –í–µ—á–Ω—ã–π —Ü–∏–∫–ª
    while True:
        await asyncio.sleep(3600)


if __name__ == "__main__":
    asyncio.run(main())


# --- File: config.py ---

import os
from dotenv import load_dotenv

load_dotenv(".env.local", override=True)
load_dotenv(".env")

BOT_TOKEN = os.getenv("BOT_TOKEN")
DATABASE_URL = os.getenv("DATABASE_URL")


# –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è S3 / MinIO
S3_ACCESS_KEY_ID = os.getenv("S3_ACCESS_KEY_ID")
S3_SECRET_ACCESS_KEY = os.getenv("S3_SECRET_ACCESS_KEY")
S3_BUCKET_NAME = os.getenv("S3_BUCKET_NAME")
S3_REGION = os.getenv("S3_REGION", "us-east-1")  # –£–∫–∞–∂–∏—Ç–µ —Å–≤–æ–π —Ä–µ–≥–∏–æ–Ω
S3_ENDPOINT_URL = os.getenv(
    "S3_ENDPOINT_URL", None
)  # –î–ª—è MinIO –∏–ª–∏ –¥—Ä—É–≥–æ–≥–æ S3-—Å–æ–≤–º–µ—Å—Ç–∏–º–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞


# –°–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –¥–∞—ë–º –Ω–∞ —Ç—Ä–∏–∞–ª –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
TRIAL_DAYS_DEFAULT = 14
# –ó–∞ —Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –¥–æ –æ–∫–æ–Ω—á–∞–Ω–∏—è —Å–ª–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
BILLING_REMIND_DAYS = 3
# –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –º—è–≥–∫–æ –æ—Ç–∫–ª—é—á–∞—Ç—å –¥–æ—Å—Ç—É–ø –ø–æ—Å–ª–µ –ø—Ä–æ—Å—Ä–æ—á–∫–∏ (True = –∑–∞–∫—Ä—ã–≤–∞–µ–º –¥–æ—Å—Ç—É–ø —Å—Ä–∞–∑—É –ø–æ expires_at)
DISABLE_ON_EXPIRE = True
# –¢–µ–ª–µ–≥—Ä–∞–º ID –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –∞–¥–º–∏–Ω–æ–≤ (–µ—Å–ª–∏ –≤–¥—Ä—É–≥ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –≤–Ω–µ —Ä–æ–ª–µ–π)
GLOBAL_ADMIN_TG_IDS = []  # –Ω–∞–ø—Ä–∏–º–µ—Ä: [123456789]
# –ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å APScheduler/cron)
NOTIFY_CHECK_INTERVAL_MIN = 30

